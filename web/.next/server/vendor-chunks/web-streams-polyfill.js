"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web-streams-polyfill";
exports.ids = ["vendor-chunks/web-streams-polyfill"];
exports.modules = {

/***/ "(rsc)/../node_modules/web-streams-polyfill/dist/ponyfill.mjs":
/*!**************************************************************!*\
  !*** ../node_modules/web-streams-polyfill/dist/ponyfill.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ByteLengthQueuingStrategy: () => (/* binding */ ByteLengthQueuingStrategy),\n/* harmony export */   CountQueuingStrategy: () => (/* binding */ CountQueuingStrategy),\n/* harmony export */   ReadableByteStreamController: () => (/* binding */ ReadableByteStreamController),\n/* harmony export */   ReadableStream: () => (/* binding */ ReadableStream),\n/* harmony export */   ReadableStreamBYOBReader: () => (/* binding */ ReadableStreamBYOBReader),\n/* harmony export */   ReadableStreamBYOBRequest: () => (/* binding */ ReadableStreamBYOBRequest),\n/* harmony export */   ReadableStreamDefaultController: () => (/* binding */ ReadableStreamDefaultController),\n/* harmony export */   ReadableStreamDefaultReader: () => (/* binding */ ReadableStreamDefaultReader),\n/* harmony export */   TransformStream: () => (/* binding */ TransformStream),\n/* harmony export */   TransformStreamDefaultController: () => (/* binding */ TransformStreamDefaultController),\n/* harmony export */   WritableStream: () => (/* binding */ WritableStream),\n/* harmony export */   WritableStreamDefaultController: () => (/* binding */ WritableStreamDefaultController),\n/* harmony export */   WritableStreamDefaultWriter: () => (/* binding */ WritableStreamDefaultWriter)\n/* harmony export */ });\n/**\n * @license\n * web-streams-polyfill v4.0.0-beta.3\n * Copyright 2021 Mattias Buelens, Diwank Singh Tomer and other contributors.\n * This code is released under the MIT license.\n * SPDX-License-Identifier: MIT\n */ const e = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? Symbol : (e)=>`Symbol(${e})`;\nfunction t() {}\nfunction r(e) {\n    return \"object\" == typeof e && null !== e || \"function\" == typeof e;\n}\nconst o = t;\nfunction n(e, t) {\n    try {\n        Object.defineProperty(e, \"name\", {\n            value: t,\n            configurable: !0\n        });\n    } catch (e) {}\n}\nconst a = Promise, i = Promise.prototype.then, l = Promise.resolve.bind(a), s = Promise.reject.bind(a);\nfunction u(e) {\n    return new a(e);\n}\nfunction c(e) {\n    return l(e);\n}\nfunction d(e) {\n    return s(e);\n}\nfunction f(e, t, r) {\n    return i.call(e, t, r);\n}\nfunction b(e, t, r) {\n    f(f(e, t, r), void 0, o);\n}\nfunction h(e, t) {\n    b(e, t);\n}\nfunction _(e, t) {\n    b(e, void 0, t);\n}\nfunction p(e, t, r) {\n    return f(e, t, r);\n}\nfunction m(e) {\n    f(e, void 0, o);\n}\nlet y = (e)=>{\n    if (\"function\" == typeof queueMicrotask) y = queueMicrotask;\n    else {\n        const e = c(void 0);\n        y = (t)=>f(e, t);\n    }\n    return y(e);\n};\nfunction g(e, t, r) {\n    if (\"function\" != typeof e) throw new TypeError(\"Argument is not a function\");\n    return Function.prototype.apply.call(e, t, r);\n}\nfunction w(e, t, r) {\n    try {\n        return c(g(e, t, r));\n    } catch (e) {\n        return d(e);\n    }\n}\nclass S {\n    constructor(){\n        this._cursor = 0, this._size = 0, this._front = {\n            _elements: [],\n            _next: void 0\n        }, this._back = this._front, this._cursor = 0, this._size = 0;\n    }\n    get length() {\n        return this._size;\n    }\n    push(e) {\n        const t = this._back;\n        let r = t;\n        16383 === t._elements.length && (r = {\n            _elements: [],\n            _next: void 0\n        }), t._elements.push(e), r !== t && (this._back = r, t._next = r), ++this._size;\n    }\n    shift() {\n        const e = this._front;\n        let t = e;\n        const r = this._cursor;\n        let o = r + 1;\n        const n = e._elements, a = n[r];\n        return 16384 === o && (t = e._next, o = 0), --this._size, this._cursor = o, e !== t && (this._front = t), n[r] = void 0, a;\n    }\n    forEach(e) {\n        let t = this._cursor, r = this._front, o = r._elements;\n        for(; !(t === o.length && void 0 === r._next || t === o.length && (r = r._next, o = r._elements, t = 0, 0 === o.length));)e(o[t]), ++t;\n    }\n    peek() {\n        const e = this._front, t = this._cursor;\n        return e._elements[t];\n    }\n}\nconst v = e(\"[[AbortSteps]]\"), R = e(\"[[ErrorSteps]]\"), T = e(\"[[CancelSteps]]\"), q = e(\"[[PullSteps]]\"), C = e(\"[[ReleaseSteps]]\");\nfunction E(e, t) {\n    e._ownerReadableStream = t, t._reader = e, \"readable\" === t._state ? O(e) : \"closed\" === t._state ? function(e) {\n        O(e), j(e);\n    }(e) : B(e, t._storedError);\n}\nfunction P(e, t) {\n    return Gt(e._ownerReadableStream, t);\n}\nfunction W(e) {\n    const t = e._ownerReadableStream;\n    \"readable\" === t._state ? A(e, new TypeError(\"Reader was released and can no longer be used to monitor the stream's closedness\")) : function(e, t) {\n        B(e, t);\n    }(e, new TypeError(\"Reader was released and can no longer be used to monitor the stream's closedness\")), t._readableStreamController[C](), t._reader = void 0, e._ownerReadableStream = void 0;\n}\nfunction k(e) {\n    return new TypeError(\"Cannot \" + e + \" a stream using a released reader\");\n}\nfunction O(e) {\n    e._closedPromise = u((t, r)=>{\n        e._closedPromise_resolve = t, e._closedPromise_reject = r;\n    });\n}\nfunction B(e, t) {\n    O(e), A(e, t);\n}\nfunction A(e, t) {\n    void 0 !== e._closedPromise_reject && (m(e._closedPromise), e._closedPromise_reject(t), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0);\n}\nfunction j(e) {\n    void 0 !== e._closedPromise_resolve && (e._closedPromise_resolve(void 0), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0);\n}\nconst z = Number.isFinite || function(e) {\n    return \"number\" == typeof e && isFinite(e);\n}, L = Math.trunc || function(e) {\n    return e < 0 ? Math.ceil(e) : Math.floor(e);\n};\nfunction F(e, t) {\n    if (void 0 !== e && \"object\" != typeof (r = e) && \"function\" != typeof r) throw new TypeError(`${t} is not an object.`);\n    var r;\n}\nfunction I(e, t) {\n    if (\"function\" != typeof e) throw new TypeError(`${t} is not a function.`);\n}\nfunction D(e, t) {\n    if (!function(e) {\n        return \"object\" == typeof e && null !== e || \"function\" == typeof e;\n    }(e)) throw new TypeError(`${t} is not an object.`);\n}\nfunction $(e, t, r) {\n    if (void 0 === e) throw new TypeError(`Parameter ${t} is required in '${r}'.`);\n}\nfunction M(e, t, r) {\n    if (void 0 === e) throw new TypeError(`${t} is required in '${r}'.`);\n}\nfunction Y(e) {\n    return Number(e);\n}\nfunction Q(e) {\n    return 0 === e ? 0 : e;\n}\nfunction N(e, t) {\n    const r = Number.MAX_SAFE_INTEGER;\n    let o = Number(e);\n    if (o = Q(o), !z(o)) throw new TypeError(`${t} is not a finite number`);\n    if (o = function(e) {\n        return Q(L(e));\n    }(o), o < 0 || o > r) throw new TypeError(`${t} is outside the accepted range of 0 to ${r}, inclusive`);\n    return z(o) && 0 !== o ? o : 0;\n}\nfunction H(e) {\n    if (!r(e)) return !1;\n    if (\"function\" != typeof e.getReader) return !1;\n    try {\n        return \"boolean\" == typeof e.locked;\n    } catch (e) {\n        return !1;\n    }\n}\nfunction x(e) {\n    if (!r(e)) return !1;\n    if (\"function\" != typeof e.getWriter) return !1;\n    try {\n        return \"boolean\" == typeof e.locked;\n    } catch (e) {\n        return !1;\n    }\n}\nfunction V(e, t) {\n    if (!Vt(e)) throw new TypeError(`${t} is not a ReadableStream.`);\n}\nfunction U(e, t) {\n    e._reader._readRequests.push(t);\n}\nfunction G(e, t, r) {\n    const o = e._reader._readRequests.shift();\n    r ? o._closeSteps() : o._chunkSteps(t);\n}\nfunction X(e) {\n    return e._reader._readRequests.length;\n}\nfunction J(e) {\n    const t = e._reader;\n    return void 0 !== t && !!K(t);\n}\nclass ReadableStreamDefaultReader {\n    constructor(e){\n        if ($(e, 1, \"ReadableStreamDefaultReader\"), V(e, \"First parameter\"), Ut(e)) throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n        E(this, e), this._readRequests = new S;\n    }\n    get closed() {\n        return K(this) ? this._closedPromise : d(ee(\"closed\"));\n    }\n    cancel(e) {\n        return K(this) ? void 0 === this._ownerReadableStream ? d(k(\"cancel\")) : P(this, e) : d(ee(\"cancel\"));\n    }\n    read() {\n        if (!K(this)) return d(ee(\"read\"));\n        if (void 0 === this._ownerReadableStream) return d(k(\"read from\"));\n        let e, t;\n        const r = u((r, o)=>{\n            e = r, t = o;\n        });\n        return function(e, t) {\n            const r = e._ownerReadableStream;\n            r._disturbed = !0, \"closed\" === r._state ? t._closeSteps() : \"errored\" === r._state ? t._errorSteps(r._storedError) : r._readableStreamController[q](t);\n        }(this, {\n            _chunkSteps: (t)=>e({\n                    value: t,\n                    done: !1\n                }),\n            _closeSteps: ()=>e({\n                    value: void 0,\n                    done: !0\n                }),\n            _errorSteps: (e)=>t(e)\n        }), r;\n    }\n    releaseLock() {\n        if (!K(this)) throw ee(\"releaseLock\");\n        void 0 !== this._ownerReadableStream && function(e) {\n            W(e);\n            const t = new TypeError(\"Reader was released\");\n            Z(e, t);\n        }(this);\n    }\n}\nfunction K(e) {\n    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, \"_readRequests\") && e instanceof ReadableStreamDefaultReader;\n}\nfunction Z(e, t) {\n    const r = e._readRequests;\n    e._readRequests = new S, r.forEach((e)=>{\n        e._errorSteps(t);\n    });\n}\nfunction ee(e) {\n    return new TypeError(`ReadableStreamDefaultReader.prototype.${e} can only be used on a ReadableStreamDefaultReader`);\n}\nObject.defineProperties(ReadableStreamDefaultReader.prototype, {\n    cancel: {\n        enumerable: !0\n    },\n    read: {\n        enumerable: !0\n    },\n    releaseLock: {\n        enumerable: !0\n    },\n    closed: {\n        enumerable: !0\n    }\n}), n(ReadableStreamDefaultReader.prototype.cancel, \"cancel\"), n(ReadableStreamDefaultReader.prototype.read, \"read\"), n(ReadableStreamDefaultReader.prototype.releaseLock, \"releaseLock\"), \"symbol\" == typeof e.toStringTag && Object.defineProperty(ReadableStreamDefaultReader.prototype, e.toStringTag, {\n    value: \"ReadableStreamDefaultReader\",\n    configurable: !0\n});\nclass te {\n    constructor(e, t){\n        this._ongoingPromise = void 0, this._isFinished = !1, this._reader = e, this._preventCancel = t;\n    }\n    next() {\n        const e = ()=>this._nextSteps();\n        return this._ongoingPromise = this._ongoingPromise ? p(this._ongoingPromise, e, e) : e(), this._ongoingPromise;\n    }\n    return(e) {\n        const t = ()=>this._returnSteps(e);\n        return this._ongoingPromise ? p(this._ongoingPromise, t, t) : t();\n    }\n    _nextSteps() {\n        if (this._isFinished) return Promise.resolve({\n            value: void 0,\n            done: !0\n        });\n        const e = this._reader;\n        return void 0 === e ? d(k(\"iterate\")) : f(e.read(), (e)=>{\n            var t;\n            return this._ongoingPromise = void 0, e.done && (this._isFinished = !0, null === (t = this._reader) || void 0 === t || t.releaseLock(), this._reader = void 0), e;\n        }, (e)=>{\n            var t;\n            throw this._ongoingPromise = void 0, this._isFinished = !0, null === (t = this._reader) || void 0 === t || t.releaseLock(), this._reader = void 0, e;\n        });\n    }\n    _returnSteps(e) {\n        if (this._isFinished) return Promise.resolve({\n            value: e,\n            done: !0\n        });\n        this._isFinished = !0;\n        const t = this._reader;\n        if (void 0 === t) return d(k(\"finish iterating\"));\n        if (this._reader = void 0, !this._preventCancel) {\n            const r = t.cancel(e);\n            return t.releaseLock(), p(r, ()=>({\n                    value: e,\n                    done: !0\n                }));\n        }\n        return t.releaseLock(), c({\n            value: e,\n            done: !0\n        });\n    }\n}\nconst re = {\n    next () {\n        return oe(this) ? this._asyncIteratorImpl.next() : d(ne(\"next\"));\n    },\n    return (e) {\n        return oe(this) ? this._asyncIteratorImpl.return(e) : d(ne(\"return\"));\n    }\n};\nfunction oe(e) {\n    if (!r(e)) return !1;\n    if (!Object.prototype.hasOwnProperty.call(e, \"_asyncIteratorImpl\")) return !1;\n    try {\n        return e._asyncIteratorImpl instanceof te;\n    } catch (e) {\n        return !1;\n    }\n}\nfunction ne(e) {\n    return new TypeError(`ReadableStreamAsyncIterator.${e} can only be used on a ReadableSteamAsyncIterator`);\n}\n\"symbol\" == typeof e.asyncIterator && Object.defineProperty(re, e.asyncIterator, {\n    value () {\n        return this;\n    },\n    writable: !0,\n    configurable: !0\n});\nconst ae = Number.isNaN || function(e) {\n    return e != e;\n};\nfunction ie(e, t, r, o, n) {\n    new Uint8Array(e).set(new Uint8Array(r, o, n), t);\n}\nfunction le(e) {\n    const t = function(e, t, r) {\n        if (e.slice) return e.slice(t, r);\n        const o = r - t, n = new ArrayBuffer(o);\n        return ie(n, 0, e, t, o), n;\n    }(e.buffer, e.byteOffset, e.byteOffset + e.byteLength);\n    return new Uint8Array(t);\n}\nfunction se(e) {\n    const t = e._queue.shift();\n    return e._queueTotalSize -= t.size, e._queueTotalSize < 0 && (e._queueTotalSize = 0), t.value;\n}\nfunction ue(e, t, r) {\n    if (\"number\" != typeof (o = r) || ae(o) || o < 0 || r === 1 / 0) throw new RangeError(\"Size must be a finite, non-NaN, non-negative number.\");\n    var o;\n    e._queue.push({\n        value: t,\n        size: r\n    }), e._queueTotalSize += r;\n}\nfunction ce(e) {\n    e._queue = new S, e._queueTotalSize = 0;\n}\nclass ReadableStreamBYOBRequest {\n    constructor(){\n        throw new TypeError(\"Illegal constructor\");\n    }\n    get view() {\n        if (!fe(this)) throw Be(\"view\");\n        return this._view;\n    }\n    respond(e) {\n        if (!fe(this)) throw Be(\"respond\");\n        if ($(e, 1, \"respond\"), e = N(e, \"First parameter\"), void 0 === this._associatedReadableByteStreamController) throw new TypeError(\"This BYOB request has been invalidated\");\n        this._view.buffer, function(e, t) {\n            const r = e._pendingPullIntos.peek();\n            if (\"closed\" === e._controlledReadableByteStream._state) {\n                if (0 !== t) throw new TypeError(\"bytesWritten must be 0 when calling respond() on a closed stream\");\n            } else {\n                if (0 === t) throw new TypeError(\"bytesWritten must be greater than 0 when calling respond() on a readable stream\");\n                if (r.bytesFilled + t > r.byteLength) throw new RangeError(\"bytesWritten out of range\");\n            }\n            r.buffer = r.buffer, qe(e, t);\n        }(this._associatedReadableByteStreamController, e);\n    }\n    respondWithNewView(e) {\n        if (!fe(this)) throw Be(\"respondWithNewView\");\n        if ($(e, 1, \"respondWithNewView\"), !ArrayBuffer.isView(e)) throw new TypeError(\"You can only respond with array buffer views\");\n        if (void 0 === this._associatedReadableByteStreamController) throw new TypeError(\"This BYOB request has been invalidated\");\n        e.buffer, function(e, t) {\n            const r = e._pendingPullIntos.peek();\n            if (\"closed\" === e._controlledReadableByteStream._state) {\n                if (0 !== t.byteLength) throw new TypeError(\"The view's length must be 0 when calling respondWithNewView() on a closed stream\");\n            } else if (0 === t.byteLength) throw new TypeError(\"The view's length must be greater than 0 when calling respondWithNewView() on a readable stream\");\n            if (r.byteOffset + r.bytesFilled !== t.byteOffset) throw new RangeError(\"The region specified by view does not match byobRequest\");\n            if (r.bufferByteLength !== t.buffer.byteLength) throw new RangeError(\"The buffer of view has different capacity than byobRequest\");\n            if (r.bytesFilled + t.byteLength > r.byteLength) throw new RangeError(\"The region specified by view is larger than byobRequest\");\n            const o = t.byteLength;\n            r.buffer = t.buffer, qe(e, o);\n        }(this._associatedReadableByteStreamController, e);\n    }\n}\nObject.defineProperties(ReadableStreamBYOBRequest.prototype, {\n    respond: {\n        enumerable: !0\n    },\n    respondWithNewView: {\n        enumerable: !0\n    },\n    view: {\n        enumerable: !0\n    }\n}), n(ReadableStreamBYOBRequest.prototype.respond, \"respond\"), n(ReadableStreamBYOBRequest.prototype.respondWithNewView, \"respondWithNewView\"), \"symbol\" == typeof e.toStringTag && Object.defineProperty(ReadableStreamBYOBRequest.prototype, e.toStringTag, {\n    value: \"ReadableStreamBYOBRequest\",\n    configurable: !0\n});\nclass ReadableByteStreamController {\n    constructor(){\n        throw new TypeError(\"Illegal constructor\");\n    }\n    get byobRequest() {\n        if (!de(this)) throw Ae(\"byobRequest\");\n        return function(e) {\n            if (null === e._byobRequest && e._pendingPullIntos.length > 0) {\n                const t = e._pendingPullIntos.peek(), r = new Uint8Array(t.buffer, t.byteOffset + t.bytesFilled, t.byteLength - t.bytesFilled), o = Object.create(ReadableStreamBYOBRequest.prototype);\n                !function(e, t, r) {\n                    e._associatedReadableByteStreamController = t, e._view = r;\n                }(o, e, r), e._byobRequest = o;\n            }\n            return e._byobRequest;\n        }(this);\n    }\n    get desiredSize() {\n        if (!de(this)) throw Ae(\"desiredSize\");\n        return ke(this);\n    }\n    close() {\n        if (!de(this)) throw Ae(\"close\");\n        if (this._closeRequested) throw new TypeError(\"The stream has already been closed; do not close it again!\");\n        const e = this._controlledReadableByteStream._state;\n        if (\"readable\" !== e) throw new TypeError(`The stream (in ${e} state) is not in the readable state and cannot be closed`);\n        !function(e) {\n            const t = e._controlledReadableByteStream;\n            if (e._closeRequested || \"readable\" !== t._state) return;\n            if (e._queueTotalSize > 0) return void (e._closeRequested = !0);\n            if (e._pendingPullIntos.length > 0) {\n                if (e._pendingPullIntos.peek().bytesFilled > 0) {\n                    const t = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n                    throw Pe(e, t), t;\n                }\n            }\n            Ee(e), Xt(t);\n        }(this);\n    }\n    enqueue(e) {\n        if (!de(this)) throw Ae(\"enqueue\");\n        if ($(e, 1, \"enqueue\"), !ArrayBuffer.isView(e)) throw new TypeError(\"chunk must be an array buffer view\");\n        if (0 === e.byteLength) throw new TypeError(\"chunk must have non-zero byteLength\");\n        if (0 === e.buffer.byteLength) throw new TypeError(\"chunk's buffer must have non-zero byteLength\");\n        if (this._closeRequested) throw new TypeError(\"stream is closed or draining\");\n        const t = this._controlledReadableByteStream._state;\n        if (\"readable\" !== t) throw new TypeError(`The stream (in ${t} state) is not in the readable state and cannot be enqueued to`);\n        !function(e, t) {\n            const r = e._controlledReadableByteStream;\n            if (e._closeRequested || \"readable\" !== r._state) return;\n            const o = t.buffer, n = t.byteOffset, a = t.byteLength, i = o;\n            if (e._pendingPullIntos.length > 0) {\n                const t = e._pendingPullIntos.peek();\n                t.buffer, Re(e), t.buffer = t.buffer, \"none\" === t.readerType && ge(e, t);\n            }\n            if (J(r)) if (function(e) {\n                const t = e._controlledReadableByteStream._reader;\n                for(; t._readRequests.length > 0;){\n                    if (0 === e._queueTotalSize) return;\n                    We(e, t._readRequests.shift());\n                }\n            }(e), 0 === X(r)) me(e, i, n, a);\n            else {\n                e._pendingPullIntos.length > 0 && Ce(e);\n                G(r, new Uint8Array(i, n, a), !1);\n            }\n            else Le(r) ? (me(e, i, n, a), Te(e)) : me(e, i, n, a);\n            be(e);\n        }(this, e);\n    }\n    error(e) {\n        if (!de(this)) throw Ae(\"error\");\n        Pe(this, e);\n    }\n    [T](e) {\n        he(this), ce(this);\n        const t = this._cancelAlgorithm(e);\n        return Ee(this), t;\n    }\n    [q](e) {\n        const t = this._controlledReadableByteStream;\n        if (this._queueTotalSize > 0) return void We(this, e);\n        const r = this._autoAllocateChunkSize;\n        if (void 0 !== r) {\n            let t;\n            try {\n                t = new ArrayBuffer(r);\n            } catch (t) {\n                return void e._errorSteps(t);\n            }\n            const o = {\n                buffer: t,\n                bufferByteLength: r,\n                byteOffset: 0,\n                byteLength: r,\n                bytesFilled: 0,\n                elementSize: 1,\n                viewConstructor: Uint8Array,\n                readerType: \"default\"\n            };\n            this._pendingPullIntos.push(o);\n        }\n        U(t, e), be(this);\n    }\n    [C]() {\n        if (this._pendingPullIntos.length > 0) {\n            const e = this._pendingPullIntos.peek();\n            e.readerType = \"none\", this._pendingPullIntos = new S, this._pendingPullIntos.push(e);\n        }\n    }\n}\nfunction de(e) {\n    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, \"_controlledReadableByteStream\") && e instanceof ReadableByteStreamController;\n}\nfunction fe(e) {\n    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, \"_associatedReadableByteStreamController\") && e instanceof ReadableStreamBYOBRequest;\n}\nfunction be(e) {\n    const t = function(e) {\n        const t = e._controlledReadableByteStream;\n        if (\"readable\" !== t._state) return !1;\n        if (e._closeRequested) return !1;\n        if (!e._started) return !1;\n        if (J(t) && X(t) > 0) return !0;\n        if (Le(t) && ze(t) > 0) return !0;\n        if (ke(e) > 0) return !0;\n        return !1;\n    }(e);\n    if (!t) return;\n    if (e._pulling) return void (e._pullAgain = !0);\n    e._pulling = !0;\n    b(e._pullAlgorithm(), ()=>(e._pulling = !1, e._pullAgain && (e._pullAgain = !1, be(e)), null), (t)=>(Pe(e, t), null));\n}\nfunction he(e) {\n    Re(e), e._pendingPullIntos = new S;\n}\nfunction _e(e, t) {\n    let r = !1;\n    \"closed\" === e._state && (r = !0);\n    const o = pe(t);\n    \"default\" === t.readerType ? G(e, o, r) : function(e, t, r) {\n        const o = e._reader._readIntoRequests.shift();\n        r ? o._closeSteps(t) : o._chunkSteps(t);\n    }(e, o, r);\n}\nfunction pe(e) {\n    const t = e.bytesFilled, r = e.elementSize;\n    return new e.viewConstructor(e.buffer, e.byteOffset, t / r);\n}\nfunction me(e, t, r, o) {\n    e._queue.push({\n        buffer: t,\n        byteOffset: r,\n        byteLength: o\n    }), e._queueTotalSize += o;\n}\nfunction ye(e, t, r, o) {\n    let n;\n    try {\n        n = t.slice(r, r + o);\n    } catch (t) {\n        throw Pe(e, t), t;\n    }\n    me(e, n, 0, o);\n}\nfunction ge(e, t) {\n    t.bytesFilled > 0 && ye(e, t.buffer, t.byteOffset, t.bytesFilled), Ce(e);\n}\nfunction we(e, t) {\n    const r = t.elementSize, o = t.bytesFilled - t.bytesFilled % r, n = Math.min(e._queueTotalSize, t.byteLength - t.bytesFilled), a = t.bytesFilled + n, i = a - a % r;\n    let l = n, s = !1;\n    i > o && (l = i - t.bytesFilled, s = !0);\n    const u = e._queue;\n    for(; l > 0;){\n        const r = u.peek(), o = Math.min(l, r.byteLength), n = t.byteOffset + t.bytesFilled;\n        ie(t.buffer, n, r.buffer, r.byteOffset, o), r.byteLength === o ? u.shift() : (r.byteOffset += o, r.byteLength -= o), e._queueTotalSize -= o, Se(e, o, t), l -= o;\n    }\n    return s;\n}\nfunction Se(e, t, r) {\n    r.bytesFilled += t;\n}\nfunction ve(e) {\n    0 === e._queueTotalSize && e._closeRequested ? (Ee(e), Xt(e._controlledReadableByteStream)) : be(e);\n}\nfunction Re(e) {\n    null !== e._byobRequest && (e._byobRequest._associatedReadableByteStreamController = void 0, e._byobRequest._view = null, e._byobRequest = null);\n}\nfunction Te(e) {\n    for(; e._pendingPullIntos.length > 0;){\n        if (0 === e._queueTotalSize) return;\n        const t = e._pendingPullIntos.peek();\n        we(e, t) && (Ce(e), _e(e._controlledReadableByteStream, t));\n    }\n}\nfunction qe(e, t) {\n    const r = e._pendingPullIntos.peek();\n    Re(e);\n    \"closed\" === e._controlledReadableByteStream._state ? function(e, t) {\n        \"none\" === t.readerType && Ce(e);\n        const r = e._controlledReadableByteStream;\n        if (Le(r)) for(; ze(r) > 0;)_e(r, Ce(e));\n    }(e, r) : function(e, t, r) {\n        if (Se(0, t, r), \"none\" === r.readerType) return ge(e, r), void Te(e);\n        if (r.bytesFilled < r.elementSize) return;\n        Ce(e);\n        const o = r.bytesFilled % r.elementSize;\n        if (o > 0) {\n            const t = r.byteOffset + r.bytesFilled;\n            ye(e, r.buffer, t - o, o);\n        }\n        r.bytesFilled -= o, _e(e._controlledReadableByteStream, r), Te(e);\n    }(e, t, r), be(e);\n}\nfunction Ce(e) {\n    return e._pendingPullIntos.shift();\n}\nfunction Ee(e) {\n    e._pullAlgorithm = void 0, e._cancelAlgorithm = void 0;\n}\nfunction Pe(e, t) {\n    const r = e._controlledReadableByteStream;\n    \"readable\" === r._state && (he(e), ce(e), Ee(e), Jt(r, t));\n}\nfunction We(e, t) {\n    const r = e._queue.shift();\n    e._queueTotalSize -= r.byteLength, ve(e);\n    const o = new Uint8Array(r.buffer, r.byteOffset, r.byteLength);\n    t._chunkSteps(o);\n}\nfunction ke(e) {\n    const t = e._controlledReadableByteStream._state;\n    return \"errored\" === t ? null : \"closed\" === t ? 0 : e._strategyHWM - e._queueTotalSize;\n}\nfunction Oe(e, t, r) {\n    const o = Object.create(ReadableByteStreamController.prototype);\n    let n, a, i;\n    n = void 0 !== t.start ? ()=>t.start(o) : ()=>{}, a = void 0 !== t.pull ? ()=>t.pull(o) : ()=>c(void 0), i = void 0 !== t.cancel ? (e)=>t.cancel(e) : ()=>c(void 0);\n    const l = t.autoAllocateChunkSize;\n    if (0 === l) throw new TypeError(\"autoAllocateChunkSize must be greater than 0\");\n    !function(e, t, r, o, n, a, i) {\n        t._controlledReadableByteStream = e, t._pullAgain = !1, t._pulling = !1, t._byobRequest = null, t._queue = t._queueTotalSize = void 0, ce(t), t._closeRequested = !1, t._started = !1, t._strategyHWM = a, t._pullAlgorithm = o, t._cancelAlgorithm = n, t._autoAllocateChunkSize = i, t._pendingPullIntos = new S, e._readableStreamController = t, b(c(r()), ()=>(t._started = !0, be(t), null), (e)=>(Pe(t, e), null));\n    }(e, o, n, a, i, r, l);\n}\nfunction Be(e) {\n    return new TypeError(`ReadableStreamBYOBRequest.prototype.${e} can only be used on a ReadableStreamBYOBRequest`);\n}\nfunction Ae(e) {\n    return new TypeError(`ReadableByteStreamController.prototype.${e} can only be used on a ReadableByteStreamController`);\n}\nfunction je(e, t) {\n    e._reader._readIntoRequests.push(t);\n}\nfunction ze(e) {\n    return e._reader._readIntoRequests.length;\n}\nfunction Le(e) {\n    const t = e._reader;\n    return void 0 !== t && !!Fe(t);\n}\nObject.defineProperties(ReadableByteStreamController.prototype, {\n    close: {\n        enumerable: !0\n    },\n    enqueue: {\n        enumerable: !0\n    },\n    error: {\n        enumerable: !0\n    },\n    byobRequest: {\n        enumerable: !0\n    },\n    desiredSize: {\n        enumerable: !0\n    }\n}), n(ReadableByteStreamController.prototype.close, \"close\"), n(ReadableByteStreamController.prototype.enqueue, \"enqueue\"), n(ReadableByteStreamController.prototype.error, \"error\"), \"symbol\" == typeof e.toStringTag && Object.defineProperty(ReadableByteStreamController.prototype, e.toStringTag, {\n    value: \"ReadableByteStreamController\",\n    configurable: !0\n});\nclass ReadableStreamBYOBReader {\n    constructor(e){\n        if ($(e, 1, \"ReadableStreamBYOBReader\"), V(e, \"First parameter\"), Ut(e)) throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n        if (!de(e._readableStreamController)) throw new TypeError(\"Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source\");\n        E(this, e), this._readIntoRequests = new S;\n    }\n    get closed() {\n        return Fe(this) ? this._closedPromise : d(De(\"closed\"));\n    }\n    cancel(e) {\n        return Fe(this) ? void 0 === this._ownerReadableStream ? d(k(\"cancel\")) : P(this, e) : d(De(\"cancel\"));\n    }\n    read(e) {\n        if (!Fe(this)) return d(De(\"read\"));\n        if (!ArrayBuffer.isView(e)) return d(new TypeError(\"view must be an array buffer view\"));\n        if (0 === e.byteLength) return d(new TypeError(\"view must have non-zero byteLength\"));\n        if (0 === e.buffer.byteLength) return d(new TypeError(\"view's buffer must have non-zero byteLength\"));\n        if (e.buffer, void 0 === this._ownerReadableStream) return d(k(\"read from\"));\n        let t, r;\n        const o = u((e, o)=>{\n            t = e, r = o;\n        });\n        return function(e, t, r) {\n            const o = e._ownerReadableStream;\n            o._disturbed = !0, \"errored\" === o._state ? r._errorSteps(o._storedError) : function(e, t, r) {\n                const o = e._controlledReadableByteStream;\n                let n = 1;\n                t.constructor !== DataView && (n = t.constructor.BYTES_PER_ELEMENT);\n                const a = t.constructor, i = t.buffer, l = {\n                    buffer: i,\n                    bufferByteLength: i.byteLength,\n                    byteOffset: t.byteOffset,\n                    byteLength: t.byteLength,\n                    bytesFilled: 0,\n                    elementSize: n,\n                    viewConstructor: a,\n                    readerType: \"byob\"\n                };\n                if (e._pendingPullIntos.length > 0) return e._pendingPullIntos.push(l), void je(o, r);\n                if (\"closed\" !== o._state) {\n                    if (e._queueTotalSize > 0) {\n                        if (we(e, l)) {\n                            const t = pe(l);\n                            return ve(e), void r._chunkSteps(t);\n                        }\n                        if (e._closeRequested) {\n                            const t = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n                            return Pe(e, t), void r._errorSteps(t);\n                        }\n                    }\n                    e._pendingPullIntos.push(l), je(o, r), be(e);\n                } else {\n                    const e = new a(l.buffer, l.byteOffset, 0);\n                    r._closeSteps(e);\n                }\n            }(o._readableStreamController, t, r);\n        }(this, e, {\n            _chunkSteps: (e)=>t({\n                    value: e,\n                    done: !1\n                }),\n            _closeSteps: (e)=>t({\n                    value: e,\n                    done: !0\n                }),\n            _errorSteps: (e)=>r(e)\n        }), o;\n    }\n    releaseLock() {\n        if (!Fe(this)) throw De(\"releaseLock\");\n        void 0 !== this._ownerReadableStream && function(e) {\n            W(e);\n            const t = new TypeError(\"Reader was released\");\n            Ie(e, t);\n        }(this);\n    }\n}\nfunction Fe(e) {\n    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, \"_readIntoRequests\") && e instanceof ReadableStreamBYOBReader;\n}\nfunction Ie(e, t) {\n    const r = e._readIntoRequests;\n    e._readIntoRequests = new S, r.forEach((e)=>{\n        e._errorSteps(t);\n    });\n}\nfunction De(e) {\n    return new TypeError(`ReadableStreamBYOBReader.prototype.${e} can only be used on a ReadableStreamBYOBReader`);\n}\nfunction $e(e, t) {\n    const { highWaterMark: r } = e;\n    if (void 0 === r) return t;\n    if (ae(r) || r < 0) throw new RangeError(\"Invalid highWaterMark\");\n    return r;\n}\nfunction Me(e) {\n    const { size: t } = e;\n    return t || (()=>1);\n}\nfunction Ye(e, t) {\n    F(e, t);\n    const r = null == e ? void 0 : e.highWaterMark, o = null == e ? void 0 : e.size;\n    return {\n        highWaterMark: void 0 === r ? void 0 : Y(r),\n        size: void 0 === o ? void 0 : Qe(o, `${t} has member 'size' that`)\n    };\n}\nfunction Qe(e, t) {\n    return I(e, t), (t)=>Y(e(t));\n}\nfunction Ne(e, t, r) {\n    return I(e, r), (r)=>w(e, t, [\n            r\n        ]);\n}\nfunction He(e, t, r) {\n    return I(e, r), ()=>w(e, t, []);\n}\nfunction xe(e, t, r) {\n    return I(e, r), (r)=>g(e, t, [\n            r\n        ]);\n}\nfunction Ve(e, t, r) {\n    return I(e, r), (r, o)=>w(e, t, [\n            r,\n            o\n        ]);\n}\nObject.defineProperties(ReadableStreamBYOBReader.prototype, {\n    cancel: {\n        enumerable: !0\n    },\n    read: {\n        enumerable: !0\n    },\n    releaseLock: {\n        enumerable: !0\n    },\n    closed: {\n        enumerable: !0\n    }\n}), n(ReadableStreamBYOBReader.prototype.cancel, \"cancel\"), n(ReadableStreamBYOBReader.prototype.read, \"read\"), n(ReadableStreamBYOBReader.prototype.releaseLock, \"releaseLock\"), \"symbol\" == typeof e.toStringTag && Object.defineProperty(ReadableStreamBYOBReader.prototype, e.toStringTag, {\n    value: \"ReadableStreamBYOBReader\",\n    configurable: !0\n});\nconst Ue = \"function\" == typeof AbortController;\nclass WritableStream {\n    constructor(e = {}, t = {}){\n        void 0 === e ? e = null : D(e, \"First parameter\");\n        const r = Ye(t, \"Second parameter\"), o = function(e, t) {\n            F(e, t);\n            const r = null == e ? void 0 : e.abort, o = null == e ? void 0 : e.close, n = null == e ? void 0 : e.start, a = null == e ? void 0 : e.type, i = null == e ? void 0 : e.write;\n            return {\n                abort: void 0 === r ? void 0 : Ne(r, e, `${t} has member 'abort' that`),\n                close: void 0 === o ? void 0 : He(o, e, `${t} has member 'close' that`),\n                start: void 0 === n ? void 0 : xe(n, e, `${t} has member 'start' that`),\n                write: void 0 === i ? void 0 : Ve(i, e, `${t} has member 'write' that`),\n                type: a\n            };\n        }(e, \"First parameter\");\n        var n;\n        (n = this)._state = \"writable\", n._storedError = void 0, n._writer = void 0, n._writableStreamController = void 0, n._writeRequests = new S, n._inFlightWriteRequest = void 0, n._closeRequest = void 0, n._inFlightCloseRequest = void 0, n._pendingAbortRequest = void 0, n._backpressure = !1;\n        if (void 0 !== o.type) throw new RangeError(\"Invalid type is specified\");\n        const a = Me(r);\n        !function(e, t, r, o) {\n            const n = Object.create(WritableStreamDefaultController.prototype);\n            let a, i, l, s;\n            a = void 0 !== t.start ? ()=>t.start(n) : ()=>{};\n            i = void 0 !== t.write ? (e)=>t.write(e, n) : ()=>c(void 0);\n            l = void 0 !== t.close ? ()=>t.close() : ()=>c(void 0);\n            s = void 0 !== t.abort ? (e)=>t.abort(e) : ()=>c(void 0);\n            !function(e, t, r, o, n, a, i, l) {\n                t._controlledWritableStream = e, e._writableStreamController = t, t._queue = void 0, t._queueTotalSize = void 0, ce(t), t._abortReason = void 0, t._abortController = function() {\n                    if (Ue) return new AbortController;\n                }(), t._started = !1, t._strategySizeAlgorithm = l, t._strategyHWM = i, t._writeAlgorithm = o, t._closeAlgorithm = n, t._abortAlgorithm = a;\n                const s = bt(t);\n                nt(e, s);\n                const u = r();\n                b(c(u), ()=>(t._started = !0, dt(t), null), (r)=>(t._started = !0, Ze(e, r), null));\n            }(e, n, a, i, l, s, r, o);\n        }(this, o, $e(r, 1), a);\n    }\n    get locked() {\n        if (!Ge(this)) throw _t(\"locked\");\n        return Xe(this);\n    }\n    abort(e) {\n        return Ge(this) ? Xe(this) ? d(new TypeError(\"Cannot abort a stream that already has a writer\")) : Je(this, e) : d(_t(\"abort\"));\n    }\n    close() {\n        return Ge(this) ? Xe(this) ? d(new TypeError(\"Cannot close a stream that already has a writer\")) : rt(this) ? d(new TypeError(\"Cannot close an already-closing stream\")) : Ke(this) : d(_t(\"close\"));\n    }\n    getWriter() {\n        if (!Ge(this)) throw _t(\"getWriter\");\n        return new WritableStreamDefaultWriter(this);\n    }\n}\nfunction Ge(e) {\n    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, \"_writableStreamController\") && e instanceof WritableStream;\n}\nfunction Xe(e) {\n    return void 0 !== e._writer;\n}\nfunction Je(e, t) {\n    var r;\n    if (\"closed\" === e._state || \"errored\" === e._state) return c(void 0);\n    e._writableStreamController._abortReason = t, null === (r = e._writableStreamController._abortController) || void 0 === r || r.abort(t);\n    const o = e._state;\n    if (\"closed\" === o || \"errored\" === o) return c(void 0);\n    if (void 0 !== e._pendingAbortRequest) return e._pendingAbortRequest._promise;\n    let n = !1;\n    \"erroring\" === o && (n = !0, t = void 0);\n    const a = u((r, o)=>{\n        e._pendingAbortRequest = {\n            _promise: void 0,\n            _resolve: r,\n            _reject: o,\n            _reason: t,\n            _wasAlreadyErroring: n\n        };\n    });\n    return e._pendingAbortRequest._promise = a, n || et(e, t), a;\n}\nfunction Ke(e) {\n    const t = e._state;\n    if (\"closed\" === t || \"errored\" === t) return d(new TypeError(`The stream (in ${t} state) is not in the writable state and cannot be closed`));\n    const r = u((t, r)=>{\n        const o = {\n            _resolve: t,\n            _reject: r\n        };\n        e._closeRequest = o;\n    }), o = e._writer;\n    var n;\n    return void 0 !== o && e._backpressure && \"writable\" === t && Et(o), ue(n = e._writableStreamController, lt, 0), dt(n), r;\n}\nfunction Ze(e, t) {\n    \"writable\" !== e._state ? tt(e) : et(e, t);\n}\nfunction et(e, t) {\n    const r = e._writableStreamController;\n    e._state = \"erroring\", e._storedError = t;\n    const o = e._writer;\n    void 0 !== o && it(o, t), !function(e) {\n        if (void 0 === e._inFlightWriteRequest && void 0 === e._inFlightCloseRequest) return !1;\n        return !0;\n    }(e) && r._started && tt(e);\n}\nfunction tt(e) {\n    e._state = \"errored\", e._writableStreamController[R]();\n    const t = e._storedError;\n    if (e._writeRequests.forEach((e)=>{\n        e._reject(t);\n    }), e._writeRequests = new S, void 0 === e._pendingAbortRequest) return void ot(e);\n    const r = e._pendingAbortRequest;\n    if (e._pendingAbortRequest = void 0, r._wasAlreadyErroring) return r._reject(t), void ot(e);\n    b(e._writableStreamController[v](r._reason), ()=>(r._resolve(), ot(e), null), (t)=>(r._reject(t), ot(e), null));\n}\nfunction rt(e) {\n    return void 0 !== e._closeRequest || void 0 !== e._inFlightCloseRequest;\n}\nfunction ot(e) {\n    void 0 !== e._closeRequest && (e._closeRequest._reject(e._storedError), e._closeRequest = void 0);\n    const t = e._writer;\n    void 0 !== t && St(t, e._storedError);\n}\nfunction nt(e, t) {\n    const r = e._writer;\n    void 0 !== r && t !== e._backpressure && (t ? function(e) {\n        Rt(e);\n    }(r) : Et(r)), e._backpressure = t;\n}\nObject.defineProperties(WritableStream.prototype, {\n    abort: {\n        enumerable: !0\n    },\n    close: {\n        enumerable: !0\n    },\n    getWriter: {\n        enumerable: !0\n    },\n    locked: {\n        enumerable: !0\n    }\n}), n(WritableStream.prototype.abort, \"abort\"), n(WritableStream.prototype.close, \"close\"), n(WritableStream.prototype.getWriter, \"getWriter\"), \"symbol\" == typeof e.toStringTag && Object.defineProperty(WritableStream.prototype, e.toStringTag, {\n    value: \"WritableStream\",\n    configurable: !0\n});\nclass WritableStreamDefaultWriter {\n    constructor(e){\n        if ($(e, 1, \"WritableStreamDefaultWriter\"), function(e, t) {\n            if (!Ge(e)) throw new TypeError(`${t} is not a WritableStream.`);\n        }(e, \"First parameter\"), Xe(e)) throw new TypeError(\"This stream has already been locked for exclusive writing by another writer\");\n        this._ownerWritableStream = e, e._writer = this;\n        const t = e._state;\n        if (\"writable\" === t) !rt(e) && e._backpressure ? Rt(this) : qt(this), gt(this);\n        else if (\"erroring\" === t) Tt(this, e._storedError), gt(this);\n        else if (\"closed\" === t) qt(this), gt(r = this), vt(r);\n        else {\n            const t = e._storedError;\n            Tt(this, t), wt(this, t);\n        }\n        var r;\n    }\n    get closed() {\n        return at(this) ? this._closedPromise : d(mt(\"closed\"));\n    }\n    get desiredSize() {\n        if (!at(this)) throw mt(\"desiredSize\");\n        if (void 0 === this._ownerWritableStream) throw yt(\"desiredSize\");\n        return function(e) {\n            const t = e._ownerWritableStream, r = t._state;\n            if (\"errored\" === r || \"erroring\" === r) return null;\n            if (\"closed\" === r) return 0;\n            return ct(t._writableStreamController);\n        }(this);\n    }\n    get ready() {\n        return at(this) ? this._readyPromise : d(mt(\"ready\"));\n    }\n    abort(e) {\n        return at(this) ? void 0 === this._ownerWritableStream ? d(yt(\"abort\")) : function(e, t) {\n            return Je(e._ownerWritableStream, t);\n        }(this, e) : d(mt(\"abort\"));\n    }\n    close() {\n        if (!at(this)) return d(mt(\"close\"));\n        const e = this._ownerWritableStream;\n        return void 0 === e ? d(yt(\"close\")) : rt(e) ? d(new TypeError(\"Cannot close an already-closing stream\")) : Ke(this._ownerWritableStream);\n    }\n    releaseLock() {\n        if (!at(this)) throw mt(\"releaseLock\");\n        void 0 !== this._ownerWritableStream && function(e) {\n            const t = e._ownerWritableStream, r = new TypeError(\"Writer was released and can no longer be used to monitor the stream's closedness\");\n            it(e, r), function(e, t) {\n                \"pending\" === e._closedPromiseState ? St(e, t) : function(e, t) {\n                    wt(e, t);\n                }(e, t);\n            }(e, r), t._writer = void 0, e._ownerWritableStream = void 0;\n        }(this);\n    }\n    write(e) {\n        return at(this) ? void 0 === this._ownerWritableStream ? d(yt(\"write to\")) : function(e, t) {\n            const r = e._ownerWritableStream, o = r._writableStreamController, n = function(e, t) {\n                try {\n                    return e._strategySizeAlgorithm(t);\n                } catch (t) {\n                    return ft(e, t), 1;\n                }\n            }(o, t);\n            if (r !== e._ownerWritableStream) return d(yt(\"write to\"));\n            const a = r._state;\n            if (\"errored\" === a) return d(r._storedError);\n            if (rt(r) || \"closed\" === a) return d(new TypeError(\"The stream is closing or closed and cannot be written to\"));\n            if (\"erroring\" === a) return d(r._storedError);\n            const i = function(e) {\n                return u((t, r)=>{\n                    const o = {\n                        _resolve: t,\n                        _reject: r\n                    };\n                    e._writeRequests.push(o);\n                });\n            }(r);\n            return function(e, t, r) {\n                try {\n                    ue(e, t, r);\n                } catch (t) {\n                    return void ft(e, t);\n                }\n                const o = e._controlledWritableStream;\n                if (!rt(o) && \"writable\" === o._state) {\n                    nt(o, bt(e));\n                }\n                dt(e);\n            }(o, t, n), i;\n        }(this, e) : d(mt(\"write\"));\n    }\n}\nfunction at(e) {\n    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, \"_ownerWritableStream\") && e instanceof WritableStreamDefaultWriter;\n}\nfunction it(e, t) {\n    \"pending\" === e._readyPromiseState ? Ct(e, t) : function(e, t) {\n        Tt(e, t);\n    }(e, t);\n}\nObject.defineProperties(WritableStreamDefaultWriter.prototype, {\n    abort: {\n        enumerable: !0\n    },\n    close: {\n        enumerable: !0\n    },\n    releaseLock: {\n        enumerable: !0\n    },\n    write: {\n        enumerable: !0\n    },\n    closed: {\n        enumerable: !0\n    },\n    desiredSize: {\n        enumerable: !0\n    },\n    ready: {\n        enumerable: !0\n    }\n}), n(WritableStreamDefaultWriter.prototype.abort, \"abort\"), n(WritableStreamDefaultWriter.prototype.close, \"close\"), n(WritableStreamDefaultWriter.prototype.releaseLock, \"releaseLock\"), n(WritableStreamDefaultWriter.prototype.write, \"write\"), \"symbol\" == typeof e.toStringTag && Object.defineProperty(WritableStreamDefaultWriter.prototype, e.toStringTag, {\n    value: \"WritableStreamDefaultWriter\",\n    configurable: !0\n});\nconst lt = {};\nclass WritableStreamDefaultController {\n    constructor(){\n        throw new TypeError(\"Illegal constructor\");\n    }\n    get abortReason() {\n        if (!st(this)) throw pt(\"abortReason\");\n        return this._abortReason;\n    }\n    get signal() {\n        if (!st(this)) throw pt(\"signal\");\n        if (void 0 === this._abortController) throw new TypeError(\"WritableStreamDefaultController.prototype.signal is not supported\");\n        return this._abortController.signal;\n    }\n    error(e) {\n        if (!st(this)) throw pt(\"error\");\n        \"writable\" === this._controlledWritableStream._state && ht(this, e);\n    }\n    [v](e) {\n        const t = this._abortAlgorithm(e);\n        return ut(this), t;\n    }\n    [R]() {\n        ce(this);\n    }\n}\nfunction st(e) {\n    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, \"_controlledWritableStream\") && e instanceof WritableStreamDefaultController;\n}\nfunction ut(e) {\n    e._writeAlgorithm = void 0, e._closeAlgorithm = void 0, e._abortAlgorithm = void 0, e._strategySizeAlgorithm = void 0;\n}\nfunction ct(e) {\n    return e._strategyHWM - e._queueTotalSize;\n}\nfunction dt(e) {\n    const t = e._controlledWritableStream;\n    if (!e._started) return;\n    if (void 0 !== t._inFlightWriteRequest) return;\n    if (\"erroring\" === t._state) return void tt(t);\n    if (0 === e._queue.length) return;\n    const r = e._queue.peek().value;\n    r === lt ? function(e) {\n        const t = e._controlledWritableStream;\n        (function(e) {\n            e._inFlightCloseRequest = e._closeRequest, e._closeRequest = void 0;\n        })(t), se(e);\n        const r = e._closeAlgorithm();\n        ut(e), b(r, ()=>((function(e) {\n                e._inFlightCloseRequest._resolve(void 0), e._inFlightCloseRequest = void 0, \"erroring\" === e._state && (e._storedError = void 0, void 0 !== e._pendingAbortRequest && (e._pendingAbortRequest._resolve(), e._pendingAbortRequest = void 0)), e._state = \"closed\";\n                const t = e._writer;\n                void 0 !== t && vt(t);\n            })(t), null), (e)=>((function(e, t) {\n                e._inFlightCloseRequest._reject(t), e._inFlightCloseRequest = void 0, void 0 !== e._pendingAbortRequest && (e._pendingAbortRequest._reject(t), e._pendingAbortRequest = void 0), Ze(e, t);\n            })(t, e), null));\n    }(e) : function(e, t) {\n        const r = e._controlledWritableStream;\n        !function(e) {\n            e._inFlightWriteRequest = e._writeRequests.shift();\n        }(r);\n        b(e._writeAlgorithm(t), ()=>{\n            !function(e) {\n                e._inFlightWriteRequest._resolve(void 0), e._inFlightWriteRequest = void 0;\n            }(r);\n            const t = r._state;\n            if (se(e), !rt(r) && \"writable\" === t) {\n                const t = bt(e);\n                nt(r, t);\n            }\n            return dt(e), null;\n        }, (t)=>(\"writable\" === r._state && ut(e), function(e, t) {\n                e._inFlightWriteRequest._reject(t), e._inFlightWriteRequest = void 0, Ze(e, t);\n            }(r, t), null));\n    }(e, r);\n}\nfunction ft(e, t) {\n    \"writable\" === e._controlledWritableStream._state && ht(e, t);\n}\nfunction bt(e) {\n    return ct(e) <= 0;\n}\nfunction ht(e, t) {\n    const r = e._controlledWritableStream;\n    ut(e), et(r, t);\n}\nfunction _t(e) {\n    return new TypeError(`WritableStream.prototype.${e} can only be used on a WritableStream`);\n}\nfunction pt(e) {\n    return new TypeError(`WritableStreamDefaultController.prototype.${e} can only be used on a WritableStreamDefaultController`);\n}\nfunction mt(e) {\n    return new TypeError(`WritableStreamDefaultWriter.prototype.${e} can only be used on a WritableStreamDefaultWriter`);\n}\nfunction yt(e) {\n    return new TypeError(\"Cannot \" + e + \" a stream using a released writer\");\n}\nfunction gt(e) {\n    e._closedPromise = u((t, r)=>{\n        e._closedPromise_resolve = t, e._closedPromise_reject = r, e._closedPromiseState = \"pending\";\n    });\n}\nfunction wt(e, t) {\n    gt(e), St(e, t);\n}\nfunction St(e, t) {\n    void 0 !== e._closedPromise_reject && (m(e._closedPromise), e._closedPromise_reject(t), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0, e._closedPromiseState = \"rejected\");\n}\nfunction vt(e) {\n    void 0 !== e._closedPromise_resolve && (e._closedPromise_resolve(void 0), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0, e._closedPromiseState = \"resolved\");\n}\nfunction Rt(e) {\n    e._readyPromise = u((t, r)=>{\n        e._readyPromise_resolve = t, e._readyPromise_reject = r;\n    }), e._readyPromiseState = \"pending\";\n}\nfunction Tt(e, t) {\n    Rt(e), Ct(e, t);\n}\nfunction qt(e) {\n    Rt(e), Et(e);\n}\nfunction Ct(e, t) {\n    void 0 !== e._readyPromise_reject && (m(e._readyPromise), e._readyPromise_reject(t), e._readyPromise_resolve = void 0, e._readyPromise_reject = void 0, e._readyPromiseState = \"rejected\");\n}\nfunction Et(e) {\n    void 0 !== e._readyPromise_resolve && (e._readyPromise_resolve(void 0), e._readyPromise_resolve = void 0, e._readyPromise_reject = void 0, e._readyPromiseState = \"fulfilled\");\n}\nObject.defineProperties(WritableStreamDefaultController.prototype, {\n    abortReason: {\n        enumerable: !0\n    },\n    signal: {\n        enumerable: !0\n    },\n    error: {\n        enumerable: !0\n    }\n}), \"symbol\" == typeof e.toStringTag && Object.defineProperty(WritableStreamDefaultController.prototype, e.toStringTag, {\n    value: \"WritableStreamDefaultController\",\n    configurable: !0\n});\nconst Pt = \"undefined\" != typeof DOMException ? DOMException : void 0;\nconst Wt = function(e) {\n    if (\"function\" != typeof e && \"object\" != typeof e) return !1;\n    try {\n        return new e, !0;\n    } catch (e) {\n        return !1;\n    }\n}(Pt) ? Pt : function() {\n    const e = function(e, t) {\n        this.message = e || \"\", this.name = t || \"Error\", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);\n    };\n    return e.prototype = Object.create(Error.prototype), Object.defineProperty(e.prototype, \"constructor\", {\n        value: e,\n        writable: !0,\n        configurable: !0\n    }), e;\n}();\nfunction kt(e, t, r, o, n, a) {\n    const i = e.getReader(), l = t.getWriter();\n    Vt(e) && (e._disturbed = !0);\n    let s, _, g, w = !1, S = !1, v = \"readable\", R = \"writable\", T = !1, q = !1;\n    const C = u((e)=>{\n        g = e;\n    });\n    let E = Promise.resolve(void 0);\n    return u((P, W)=>{\n        let k;\n        function O() {\n            if (w) return;\n            const e = u((e, t)=>{\n                !function r(o) {\n                    o ? e() : f(function() {\n                        if (w) return c(!0);\n                        return f(l.ready, ()=>f(i.read(), (e)=>!!e.done || (E = l.write(e.value), m(E), !1)));\n                    }(), r, t);\n                }(!1);\n            });\n            m(e);\n        }\n        function B() {\n            return v = \"closed\", r ? L() : z(()=>(Ge(t) && (T = rt(t), R = t._state), T || \"closed\" === R ? c(void 0) : \"erroring\" === R || \"errored\" === R ? d(_) : (T = !0, l.close())), !1, void 0), null;\n        }\n        function A(e) {\n            return w || (v = \"errored\", s = e, o ? L(!0, e) : z(()=>l.abort(e), !0, e)), null;\n        }\n        function j(e) {\n            return S || (R = \"errored\", _ = e, n ? L(!0, e) : z(()=>i.cancel(e), !0, e)), null;\n        }\n        if (void 0 !== a && (k = ()=>{\n            const e = void 0 !== a.reason ? a.reason : new Wt(\"Aborted\", \"AbortError\"), t = [];\n            o || t.push(()=>\"writable\" === R ? l.abort(e) : c(void 0)), n || t.push(()=>\"readable\" === v ? i.cancel(e) : c(void 0)), z(()=>Promise.all(t.map((e)=>e())), !0, e);\n        }, a.aborted ? k() : a.addEventListener(\"abort\", k)), Vt(e) && (v = e._state, s = e._storedError), Ge(t) && (R = t._state, _ = t._storedError, T = rt(t)), Vt(e) && Ge(t) && (q = !0, g()), \"errored\" === v) A(s);\n        else if (\"erroring\" === R || \"errored\" === R) j(_);\n        else if (\"closed\" === v) B();\n        else if (T || \"closed\" === R) {\n            const e = new TypeError(\"the destination writable stream closed before all data could be piped to it\");\n            n ? L(!0, e) : z(()=>i.cancel(e), !0, e);\n        }\n        function z(e, t, r) {\n            function o() {\n                return \"writable\" !== R || T ? n() : h(function() {\n                    let e;\n                    return c(function t() {\n                        if (e !== E) return e = E, p(E, t, t);\n                    }());\n                }(), n), null;\n            }\n            function n() {\n                return e ? b(e(), ()=>F(t, r), (e)=>F(!0, e)) : F(t, r), null;\n            }\n            w || (w = !0, q ? o() : h(C, o));\n        }\n        function L(e, t) {\n            z(void 0, e, t);\n        }\n        function F(e, t) {\n            return S = !0, l.releaseLock(), i.releaseLock(), void 0 !== a && a.removeEventListener(\"abort\", k), e ? W(t) : P(void 0), null;\n        }\n        w || (b(i.closed, B, A), b(l.closed, function() {\n            return S || (R = \"closed\"), null;\n        }, j)), q ? O() : y(()=>{\n            q = !0, g(), O();\n        });\n    });\n}\nfunction Ot(e, t) {\n    return function(e) {\n        try {\n            return e.getReader({\n                mode: \"byob\"\n            }).releaseLock(), !0;\n        } catch (e) {\n            return !1;\n        }\n    }(e) ? function(e) {\n        let t, r, o, n, a, i = e.getReader(), l = !1, s = !1, d = !1, f = !1, h = !1, p = !1;\n        const m = u((e)=>{\n            a = e;\n        });\n        function y(e) {\n            _(e.closed, (t)=>(e !== i || (o.error(t), n.error(t), h && p || a(void 0)), null));\n        }\n        function g() {\n            l && (i.releaseLock(), i = e.getReader(), y(i), l = !1), b(i.read(), (e)=>{\n                var t, r;\n                if (d = !1, f = !1, e.done) return h || o.close(), p || n.close(), null === (t = o.byobRequest) || void 0 === t || t.respond(0), null === (r = n.byobRequest) || void 0 === r || r.respond(0), h && p || a(void 0), null;\n                const l = e.value, u = l;\n                let c = l;\n                if (!h && !p) try {\n                    c = le(l);\n                } catch (e) {\n                    return o.error(e), n.error(e), a(i.cancel(e)), null;\n                }\n                return h || o.enqueue(u), p || n.enqueue(c), s = !1, d ? S() : f && v(), null;\n            }, ()=>(s = !1, null));\n        }\n        function w(t, r) {\n            l || (i.releaseLock(), i = e.getReader({\n                mode: \"byob\"\n            }), y(i), l = !0);\n            const u = r ? n : o, c = r ? o : n;\n            b(i.read(t), (e)=>{\n                var t;\n                d = !1, f = !1;\n                const o = r ? p : h, n = r ? h : p;\n                if (e.done) {\n                    o || u.close(), n || c.close();\n                    const r = e.value;\n                    return void 0 !== r && (o || u.byobRequest.respondWithNewView(r), n || null === (t = c.byobRequest) || void 0 === t || t.respond(0)), o && n || a(void 0), null;\n                }\n                const l = e.value;\n                if (n) o || u.byobRequest.respondWithNewView(l);\n                else {\n                    let e;\n                    try {\n                        e = le(l);\n                    } catch (e) {\n                        return u.error(e), c.error(e), a(i.cancel(e)), null;\n                    }\n                    o || u.byobRequest.respondWithNewView(l), c.enqueue(e);\n                }\n                return s = !1, d ? S() : f && v(), null;\n            }, ()=>(s = !1, null));\n        }\n        function S() {\n            if (s) return d = !0, c(void 0);\n            s = !0;\n            const e = o.byobRequest;\n            return null === e ? g() : w(e.view, !1), c(void 0);\n        }\n        function v() {\n            if (s) return f = !0, c(void 0);\n            s = !0;\n            const e = n.byobRequest;\n            return null === e ? g() : w(e.view, !0), c(void 0);\n        }\n        function R(e) {\n            if (h = !0, t = e, p) {\n                const e = [\n                    t,\n                    r\n                ], o = i.cancel(e);\n                a(o);\n            }\n            return m;\n        }\n        function T(e) {\n            if (p = !0, r = e, h) {\n                const e = [\n                    t,\n                    r\n                ], o = i.cancel(e);\n                a(o);\n            }\n            return m;\n        }\n        const q = new ReadableStream({\n            type: \"bytes\",\n            start (e) {\n                o = e;\n            },\n            pull: S,\n            cancel: R\n        }), C = new ReadableStream({\n            type: \"bytes\",\n            start (e) {\n                n = e;\n            },\n            pull: v,\n            cancel: T\n        });\n        return y(i), [\n            q,\n            C\n        ];\n    }(e) : function(e, t) {\n        const r = e.getReader();\n        let o, n, a, i, l, s = !1, d = !1, f = !1, h = !1;\n        const p = u((e)=>{\n            l = e;\n        });\n        function m() {\n            return s ? (d = !0, c(void 0)) : (s = !0, b(r.read(), (e)=>{\n                if (d = !1, e.done) return f || a.close(), h || i.close(), f && h || l(void 0), null;\n                const t = e.value, r = t, o = t;\n                return f || a.enqueue(r), h || i.enqueue(o), s = !1, d && m(), null;\n            }, ()=>(s = !1, null)), c(void 0));\n        }\n        function y(e) {\n            if (f = !0, o = e, h) {\n                const e = [\n                    o,\n                    n\n                ], t = r.cancel(e);\n                l(t);\n            }\n            return p;\n        }\n        function g(e) {\n            if (h = !0, n = e, f) {\n                const e = [\n                    o,\n                    n\n                ], t = r.cancel(e);\n                l(t);\n            }\n            return p;\n        }\n        const w = new ReadableStream({\n            start (e) {\n                a = e;\n            },\n            pull: m,\n            cancel: y\n        }), S = new ReadableStream({\n            start (e) {\n                i = e;\n            },\n            pull: m,\n            cancel: g\n        });\n        return _(r.closed, (e)=>(a.error(e), i.error(e), f && h || l(void 0), null)), [\n            w,\n            S\n        ];\n    }(e);\n}\nclass ReadableStreamDefaultController {\n    constructor(){\n        throw new TypeError(\"Illegal constructor\");\n    }\n    get desiredSize() {\n        if (!Bt(this)) throw Dt(\"desiredSize\");\n        return Lt(this);\n    }\n    close() {\n        if (!Bt(this)) throw Dt(\"close\");\n        if (!Ft(this)) throw new TypeError(\"The stream is not in a state that permits close\");\n        !function(e) {\n            if (!Ft(e)) return;\n            const t = e._controlledReadableStream;\n            e._closeRequested = !0, 0 === e._queue.length && (jt(e), Xt(t));\n        }(this);\n    }\n    enqueue(e) {\n        if (!Bt(this)) throw Dt(\"enqueue\");\n        if (!Ft(this)) throw new TypeError(\"The stream is not in a state that permits enqueue\");\n        return function(e, t) {\n            if (!Ft(e)) return;\n            const r = e._controlledReadableStream;\n            if (Ut(r) && X(r) > 0) G(r, t, !1);\n            else {\n                let r;\n                try {\n                    r = e._strategySizeAlgorithm(t);\n                } catch (t) {\n                    throw zt(e, t), t;\n                }\n                try {\n                    ue(e, t, r);\n                } catch (t) {\n                    throw zt(e, t), t;\n                }\n            }\n            At(e);\n        }(this, e);\n    }\n    error(e) {\n        if (!Bt(this)) throw Dt(\"error\");\n        zt(this, e);\n    }\n    [T](e) {\n        ce(this);\n        const t = this._cancelAlgorithm(e);\n        return jt(this), t;\n    }\n    [q](e) {\n        const t = this._controlledReadableStream;\n        if (this._queue.length > 0) {\n            const r = se(this);\n            this._closeRequested && 0 === this._queue.length ? (jt(this), Xt(t)) : At(this), e._chunkSteps(r);\n        } else U(t, e), At(this);\n    }\n    [C]() {}\n}\nfunction Bt(e) {\n    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, \"_controlledReadableStream\") && e instanceof ReadableStreamDefaultController;\n}\nfunction At(e) {\n    const t = function(e) {\n        const t = e._controlledReadableStream;\n        if (!Ft(e)) return !1;\n        if (!e._started) return !1;\n        if (Ut(t) && X(t) > 0) return !0;\n        if (Lt(e) > 0) return !0;\n        return !1;\n    }(e);\n    if (!t) return;\n    if (e._pulling) return void (e._pullAgain = !0);\n    e._pulling = !0;\n    b(e._pullAlgorithm(), ()=>(e._pulling = !1, e._pullAgain && (e._pullAgain = !1, At(e)), null), (t)=>(zt(e, t), null));\n}\nfunction jt(e) {\n    e._pullAlgorithm = void 0, e._cancelAlgorithm = void 0, e._strategySizeAlgorithm = void 0;\n}\nfunction zt(e, t) {\n    const r = e._controlledReadableStream;\n    \"readable\" === r._state && (ce(e), jt(e), Jt(r, t));\n}\nfunction Lt(e) {\n    const t = e._controlledReadableStream._state;\n    return \"errored\" === t ? null : \"closed\" === t ? 0 : e._strategyHWM - e._queueTotalSize;\n}\nfunction Ft(e) {\n    return !e._closeRequested && \"readable\" === e._controlledReadableStream._state;\n}\nfunction It(e, t, r, o) {\n    const n = Object.create(ReadableStreamDefaultController.prototype);\n    let a, i, l;\n    a = void 0 !== t.start ? ()=>t.start(n) : ()=>{}, i = void 0 !== t.pull ? ()=>t.pull(n) : ()=>c(void 0), l = void 0 !== t.cancel ? (e)=>t.cancel(e) : ()=>c(void 0), function(e, t, r, o, n, a, i) {\n        t._controlledReadableStream = e, t._queue = void 0, t._queueTotalSize = void 0, ce(t), t._started = !1, t._closeRequested = !1, t._pullAgain = !1, t._pulling = !1, t._strategySizeAlgorithm = i, t._strategyHWM = a, t._pullAlgorithm = o, t._cancelAlgorithm = n, e._readableStreamController = t, b(c(r()), ()=>(t._started = !0, At(t), null), (e)=>(zt(t, e), null));\n    }(e, n, a, i, l, r, o);\n}\nfunction Dt(e) {\n    return new TypeError(`ReadableStreamDefaultController.prototype.${e} can only be used on a ReadableStreamDefaultController`);\n}\nfunction $t(e, t, r) {\n    return I(e, r), (r)=>w(e, t, [\n            r\n        ]);\n}\nfunction Mt(e, t, r) {\n    return I(e, r), (r)=>w(e, t, [\n            r\n        ]);\n}\nfunction Yt(e, t, r) {\n    return I(e, r), (r)=>g(e, t, [\n            r\n        ]);\n}\nfunction Qt(e, t) {\n    if (\"bytes\" !== (e = `${e}`)) throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamType`);\n    return e;\n}\nfunction Nt(e, t) {\n    if (\"byob\" !== (e = `${e}`)) throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamReaderMode`);\n    return e;\n}\nfunction Ht(e, t) {\n    F(e, t);\n    const r = null == e ? void 0 : e.preventAbort, o = null == e ? void 0 : e.preventCancel, n = null == e ? void 0 : e.preventClose, a = null == e ? void 0 : e.signal;\n    return void 0 !== a && function(e, t) {\n        if (!function(e) {\n            if (\"object\" != typeof e || null === e) return !1;\n            try {\n                return \"boolean\" == typeof e.aborted;\n            } catch (e) {\n                return !1;\n            }\n        }(e)) throw new TypeError(`${t} is not an AbortSignal.`);\n    }(a, `${t} has member 'signal' that`), {\n        preventAbort: Boolean(r),\n        preventCancel: Boolean(o),\n        preventClose: Boolean(n),\n        signal: a\n    };\n}\nfunction xt(e, t) {\n    F(e, t);\n    const r = null == e ? void 0 : e.readable;\n    M(r, \"readable\", \"ReadableWritablePair\"), function(e, t) {\n        if (!H(e)) throw new TypeError(`${t} is not a ReadableStream.`);\n    }(r, `${t} has member 'readable' that`);\n    const o = null == e ? void 0 : e.writable;\n    return M(o, \"writable\", \"ReadableWritablePair\"), function(e, t) {\n        if (!x(e)) throw new TypeError(`${t} is not a WritableStream.`);\n    }(o, `${t} has member 'writable' that`), {\n        readable: r,\n        writable: o\n    };\n}\nObject.defineProperties(ReadableStreamDefaultController.prototype, {\n    close: {\n        enumerable: !0\n    },\n    enqueue: {\n        enumerable: !0\n    },\n    error: {\n        enumerable: !0\n    },\n    desiredSize: {\n        enumerable: !0\n    }\n}), n(ReadableStreamDefaultController.prototype.close, \"close\"), n(ReadableStreamDefaultController.prototype.enqueue, \"enqueue\"), n(ReadableStreamDefaultController.prototype.error, \"error\"), \"symbol\" == typeof e.toStringTag && Object.defineProperty(ReadableStreamDefaultController.prototype, e.toStringTag, {\n    value: \"ReadableStreamDefaultController\",\n    configurable: !0\n});\nclass ReadableStream {\n    constructor(e = {}, t = {}){\n        void 0 === e ? e = null : D(e, \"First parameter\");\n        const r = Ye(t, \"Second parameter\"), o = function(e, t) {\n            F(e, t);\n            const r = e, o = null == r ? void 0 : r.autoAllocateChunkSize, n = null == r ? void 0 : r.cancel, a = null == r ? void 0 : r.pull, i = null == r ? void 0 : r.start, l = null == r ? void 0 : r.type;\n            return {\n                autoAllocateChunkSize: void 0 === o ? void 0 : N(o, `${t} has member 'autoAllocateChunkSize' that`),\n                cancel: void 0 === n ? void 0 : $t(n, r, `${t} has member 'cancel' that`),\n                pull: void 0 === a ? void 0 : Mt(a, r, `${t} has member 'pull' that`),\n                start: void 0 === i ? void 0 : Yt(i, r, `${t} has member 'start' that`),\n                type: void 0 === l ? void 0 : Qt(l, `${t} has member 'type' that`)\n            };\n        }(e, \"First parameter\");\n        var n;\n        if ((n = this)._state = \"readable\", n._reader = void 0, n._storedError = void 0, n._disturbed = !1, \"bytes\" === o.type) {\n            if (void 0 !== r.size) throw new RangeError(\"The strategy for a byte stream cannot have a size function\");\n            Oe(this, o, $e(r, 0));\n        } else {\n            const e = Me(r);\n            It(this, o, $e(r, 1), e);\n        }\n    }\n    get locked() {\n        if (!Vt(this)) throw Kt(\"locked\");\n        return Ut(this);\n    }\n    cancel(e) {\n        return Vt(this) ? Ut(this) ? d(new TypeError(\"Cannot cancel a stream that already has a reader\")) : Gt(this, e) : d(Kt(\"cancel\"));\n    }\n    getReader(e) {\n        if (!Vt(this)) throw Kt(\"getReader\");\n        return void 0 === function(e, t) {\n            F(e, t);\n            const r = null == e ? void 0 : e.mode;\n            return {\n                mode: void 0 === r ? void 0 : Nt(r, `${t} has member 'mode' that`)\n            };\n        }(e, \"First parameter\").mode ? new ReadableStreamDefaultReader(this) : function(e) {\n            return new ReadableStreamBYOBReader(e);\n        }(this);\n    }\n    pipeThrough(e, t = {}) {\n        if (!H(this)) throw Kt(\"pipeThrough\");\n        $(e, 1, \"pipeThrough\");\n        const r = xt(e, \"First parameter\"), o = Ht(t, \"Second parameter\");\n        if (this.locked) throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream\");\n        if (r.writable.locked) throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream\");\n        return m(kt(this, r.writable, o.preventClose, o.preventAbort, o.preventCancel, o.signal)), r.readable;\n    }\n    pipeTo(e, t = {}) {\n        if (!H(this)) return d(Kt(\"pipeTo\"));\n        if (void 0 === e) return d(\"Parameter 1 is required in 'pipeTo'.\");\n        if (!x(e)) return d(new TypeError(\"ReadableStream.prototype.pipeTo's first argument must be a WritableStream\"));\n        let r;\n        try {\n            r = Ht(t, \"Second parameter\");\n        } catch (e) {\n            return d(e);\n        }\n        return this.locked ? d(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream\")) : e.locked ? d(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream\")) : kt(this, e, r.preventClose, r.preventAbort, r.preventCancel, r.signal);\n    }\n    tee() {\n        if (!H(this)) throw Kt(\"tee\");\n        if (this.locked) throw new TypeError(\"Cannot tee a stream that already has a reader\");\n        return Ot(this);\n    }\n    values(e) {\n        if (!H(this)) throw Kt(\"values\");\n        return function(e, t) {\n            const r = e.getReader(), o = new te(r, t), n = Object.create(re);\n            return n._asyncIteratorImpl = o, n;\n        }(this, function(e, t) {\n            F(e, t);\n            const r = null == e ? void 0 : e.preventCancel;\n            return {\n                preventCancel: Boolean(r)\n            };\n        }(e, \"First parameter\").preventCancel);\n    }\n}\nfunction Vt(e) {\n    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, \"_readableStreamController\") && e instanceof ReadableStream;\n}\nfunction Ut(e) {\n    return void 0 !== e._reader;\n}\nfunction Gt(e, r) {\n    if (e._disturbed = !0, \"closed\" === e._state) return c(void 0);\n    if (\"errored\" === e._state) return d(e._storedError);\n    Xt(e);\n    const o = e._reader;\n    if (void 0 !== o && Fe(o)) {\n        const e = o._readIntoRequests;\n        o._readIntoRequests = new S, e.forEach((e)=>{\n            e._closeSteps(void 0);\n        });\n    }\n    return p(e._readableStreamController[T](r), t);\n}\nfunction Xt(e) {\n    e._state = \"closed\";\n    const t = e._reader;\n    if (void 0 !== t && (j(t), K(t))) {\n        const e = t._readRequests;\n        t._readRequests = new S, e.forEach((e)=>{\n            e._closeSteps();\n        });\n    }\n}\nfunction Jt(e, t) {\n    e._state = \"errored\", e._storedError = t;\n    const r = e._reader;\n    void 0 !== r && (A(r, t), K(r) ? Z(r, t) : Ie(r, t));\n}\nfunction Kt(e) {\n    return new TypeError(`ReadableStream.prototype.${e} can only be used on a ReadableStream`);\n}\nfunction Zt(e, t) {\n    F(e, t);\n    const r = null == e ? void 0 : e.highWaterMark;\n    return M(r, \"highWaterMark\", \"QueuingStrategyInit\"), {\n        highWaterMark: Y(r)\n    };\n}\nObject.defineProperties(ReadableStream.prototype, {\n    cancel: {\n        enumerable: !0\n    },\n    getReader: {\n        enumerable: !0\n    },\n    pipeThrough: {\n        enumerable: !0\n    },\n    pipeTo: {\n        enumerable: !0\n    },\n    tee: {\n        enumerable: !0\n    },\n    values: {\n        enumerable: !0\n    },\n    locked: {\n        enumerable: !0\n    }\n}), n(ReadableStream.prototype.cancel, \"cancel\"), n(ReadableStream.prototype.getReader, \"getReader\"), n(ReadableStream.prototype.pipeThrough, \"pipeThrough\"), n(ReadableStream.prototype.pipeTo, \"pipeTo\"), n(ReadableStream.prototype.tee, \"tee\"), n(ReadableStream.prototype.values, \"values\"), \"symbol\" == typeof e.toStringTag && Object.defineProperty(ReadableStream.prototype, e.toStringTag, {\n    value: \"ReadableStream\",\n    configurable: !0\n}), \"symbol\" == typeof e.asyncIterator && Object.defineProperty(ReadableStream.prototype, e.asyncIterator, {\n    value: ReadableStream.prototype.values,\n    writable: !0,\n    configurable: !0\n});\nconst er = (e)=>e.byteLength;\nn(er, \"size\");\nclass ByteLengthQueuingStrategy {\n    constructor(e){\n        $(e, 1, \"ByteLengthQueuingStrategy\"), e = Zt(e, \"First parameter\"), this._byteLengthQueuingStrategyHighWaterMark = e.highWaterMark;\n    }\n    get highWaterMark() {\n        if (!rr(this)) throw tr(\"highWaterMark\");\n        return this._byteLengthQueuingStrategyHighWaterMark;\n    }\n    get size() {\n        if (!rr(this)) throw tr(\"size\");\n        return er;\n    }\n}\nfunction tr(e) {\n    return new TypeError(`ByteLengthQueuingStrategy.prototype.${e} can only be used on a ByteLengthQueuingStrategy`);\n}\nfunction rr(e) {\n    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, \"_byteLengthQueuingStrategyHighWaterMark\") && e instanceof ByteLengthQueuingStrategy;\n}\nObject.defineProperties(ByteLengthQueuingStrategy.prototype, {\n    highWaterMark: {\n        enumerable: !0\n    },\n    size: {\n        enumerable: !0\n    }\n}), \"symbol\" == typeof e.toStringTag && Object.defineProperty(ByteLengthQueuingStrategy.prototype, e.toStringTag, {\n    value: \"ByteLengthQueuingStrategy\",\n    configurable: !0\n});\nconst or = ()=>1;\nn(or, \"size\");\nclass CountQueuingStrategy {\n    constructor(e){\n        $(e, 1, \"CountQueuingStrategy\"), e = Zt(e, \"First parameter\"), this._countQueuingStrategyHighWaterMark = e.highWaterMark;\n    }\n    get highWaterMark() {\n        if (!ar(this)) throw nr(\"highWaterMark\");\n        return this._countQueuingStrategyHighWaterMark;\n    }\n    get size() {\n        if (!ar(this)) throw nr(\"size\");\n        return or;\n    }\n}\nfunction nr(e) {\n    return new TypeError(`CountQueuingStrategy.prototype.${e} can only be used on a CountQueuingStrategy`);\n}\nfunction ar(e) {\n    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, \"_countQueuingStrategyHighWaterMark\") && e instanceof CountQueuingStrategy;\n}\nfunction ir(e, t, r) {\n    return I(e, r), (r)=>w(e, t, [\n            r\n        ]);\n}\nfunction lr(e, t, r) {\n    return I(e, r), (r)=>g(e, t, [\n            r\n        ]);\n}\nfunction sr(e, t, r) {\n    return I(e, r), (r, o)=>w(e, t, [\n            r,\n            o\n        ]);\n}\nObject.defineProperties(CountQueuingStrategy.prototype, {\n    highWaterMark: {\n        enumerable: !0\n    },\n    size: {\n        enumerable: !0\n    }\n}), \"symbol\" == typeof e.toStringTag && Object.defineProperty(CountQueuingStrategy.prototype, e.toStringTag, {\n    value: \"CountQueuingStrategy\",\n    configurable: !0\n});\nclass TransformStream {\n    constructor(e = {}, t = {}, r = {}){\n        void 0 === e && (e = null);\n        const o = Ye(t, \"Second parameter\"), n = Ye(r, \"Third parameter\"), a = function(e, t) {\n            F(e, t);\n            const r = null == e ? void 0 : e.flush, o = null == e ? void 0 : e.readableType, n = null == e ? void 0 : e.start, a = null == e ? void 0 : e.transform, i = null == e ? void 0 : e.writableType;\n            return {\n                flush: void 0 === r ? void 0 : ir(r, e, `${t} has member 'flush' that`),\n                readableType: o,\n                start: void 0 === n ? void 0 : lr(n, e, `${t} has member 'start' that`),\n                transform: void 0 === a ? void 0 : sr(a, e, `${t} has member 'transform' that`),\n                writableType: i\n            };\n        }(e, \"First parameter\");\n        if (void 0 !== a.readableType) throw new RangeError(\"Invalid readableType specified\");\n        if (void 0 !== a.writableType) throw new RangeError(\"Invalid writableType specified\");\n        const i = $e(n, 0), l = Me(n), s = $e(o, 1), f = Me(o);\n        let b;\n        !function(e, t, r, o, n, a) {\n            function i() {\n                return t;\n            }\n            function l(t) {\n                return function(e, t) {\n                    const r = e._transformStreamController;\n                    if (e._backpressure) {\n                        return p(e._backpressureChangePromise, ()=>{\n                            if (\"erroring\" === (Ge(e._writable) ? e._writable._state : e._writableState)) throw Ge(e._writable) ? e._writable._storedError : e._writableStoredError;\n                            return pr(r, t);\n                        });\n                    }\n                    return pr(r, t);\n                }(e, t);\n            }\n            function s(t) {\n                return function(e, t) {\n                    return cr(e, t), c(void 0);\n                }(e, t);\n            }\n            function u() {\n                return function(e) {\n                    const t = e._transformStreamController, r = t._flushAlgorithm();\n                    return hr(t), p(r, ()=>{\n                        if (\"errored\" === e._readableState) throw e._readableStoredError;\n                        gr(e) && wr(e);\n                    }, (t)=>{\n                        throw cr(e, t), e._readableStoredError;\n                    });\n                }(e);\n            }\n            function d() {\n                return function(e) {\n                    return fr(e, !1), e._backpressureChangePromise;\n                }(e);\n            }\n            function f(t) {\n                return dr(e, t), c(void 0);\n            }\n            e._writableState = \"writable\", e._writableStoredError = void 0, e._writableHasInFlightOperation = !1, e._writableStarted = !1, e._writable = function(e, t, r, o, n, a, i) {\n                return new WritableStream({\n                    start (r) {\n                        e._writableController = r;\n                        try {\n                            const t = r.signal;\n                            void 0 !== t && t.addEventListener(\"abort\", ()=>{\n                                \"writable\" === e._writableState && (e._writableState = \"erroring\", t.reason && (e._writableStoredError = t.reason));\n                            });\n                        } catch (e) {}\n                        return p(t(), ()=>(e._writableStarted = !0, Cr(e), null), (t)=>{\n                            throw e._writableStarted = !0, Rr(e, t), t;\n                        });\n                    },\n                    write: (t)=>((function(e) {\n                            e._writableHasInFlightOperation = !0;\n                        })(e), p(r(t), ()=>((function(e) {\n                                e._writableHasInFlightOperation = !1;\n                            })(e), Cr(e), null), (t)=>{\n                            throw function(e, t) {\n                                e._writableHasInFlightOperation = !1, Rr(e, t);\n                            }(e, t), t;\n                        })),\n                    close: ()=>((function(e) {\n                            e._writableHasInFlightOperation = !0;\n                        })(e), p(o(), ()=>((function(e) {\n                                e._writableHasInFlightOperation = !1;\n                                \"erroring\" === e._writableState && (e._writableStoredError = void 0);\n                                e._writableState = \"closed\";\n                            })(e), null), (t)=>{\n                            throw function(e, t) {\n                                e._writableHasInFlightOperation = !1, e._writableState, Rr(e, t);\n                            }(e, t), t;\n                        })),\n                    abort: (t)=>(e._writableState = \"errored\", e._writableStoredError = t, n(t))\n                }, {\n                    highWaterMark: a,\n                    size: i\n                });\n            }(e, i, l, u, s, r, o), e._readableState = \"readable\", e._readableStoredError = void 0, e._readableCloseRequested = !1, e._readablePulling = !1, e._readable = function(e, t, r, o, n, a) {\n                return new ReadableStream({\n                    start: (r)=>(e._readableController = r, t().catch((t)=>{\n                            Sr(e, t);\n                        })),\n                    pull: ()=>(e._readablePulling = !0, r().catch((t)=>{\n                            Sr(e, t);\n                        })),\n                    cancel: (t)=>(e._readableState = \"closed\", o(t))\n                }, {\n                    highWaterMark: n,\n                    size: a\n                });\n            }(e, i, d, f, n, a), e._backpressure = void 0, e._backpressureChangePromise = void 0, e._backpressureChangePromise_resolve = void 0, fr(e, !0), e._transformStreamController = void 0;\n        }(this, u((e)=>{\n            b = e;\n        }), s, f, i, l), function(e, t) {\n            const r = Object.create(TransformStreamDefaultController.prototype);\n            let o, n;\n            o = void 0 !== t.transform ? (e)=>t.transform(e, r) : (e)=>{\n                try {\n                    return _r(r, e), c(void 0);\n                } catch (e) {\n                    return d(e);\n                }\n            };\n            n = void 0 !== t.flush ? ()=>t.flush(r) : ()=>c(void 0);\n            !function(e, t, r, o) {\n                t._controlledTransformStream = e, e._transformStreamController = t, t._transformAlgorithm = r, t._flushAlgorithm = o;\n            }(e, r, o, n);\n        }(this, a), void 0 !== a.start ? b(a.start(this._transformStreamController)) : b(void 0);\n    }\n    get readable() {\n        if (!ur(this)) throw yr(\"readable\");\n        return this._readable;\n    }\n    get writable() {\n        if (!ur(this)) throw yr(\"writable\");\n        return this._writable;\n    }\n}\nfunction ur(e) {\n    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, \"_transformStreamController\") && e instanceof TransformStream;\n}\nfunction cr(e, t) {\n    Sr(e, t), dr(e, t);\n}\nfunction dr(e, t) {\n    hr(e._transformStreamController), function(e, t) {\n        e._writableController.error(t);\n        \"writable\" === e._writableState && Tr(e, t);\n    }(e, t), e._backpressure && fr(e, !1);\n}\nfunction fr(e, t) {\n    void 0 !== e._backpressureChangePromise && e._backpressureChangePromise_resolve(), e._backpressureChangePromise = u((t)=>{\n        e._backpressureChangePromise_resolve = t;\n    }), e._backpressure = t;\n}\nObject.defineProperties(TransformStream.prototype, {\n    readable: {\n        enumerable: !0\n    },\n    writable: {\n        enumerable: !0\n    }\n}), \"symbol\" == typeof e.toStringTag && Object.defineProperty(TransformStream.prototype, e.toStringTag, {\n    value: \"TransformStream\",\n    configurable: !0\n});\nclass TransformStreamDefaultController {\n    constructor(){\n        throw new TypeError(\"Illegal constructor\");\n    }\n    get desiredSize() {\n        if (!br(this)) throw mr(\"desiredSize\");\n        return vr(this._controlledTransformStream);\n    }\n    enqueue(e) {\n        if (!br(this)) throw mr(\"enqueue\");\n        _r(this, e);\n    }\n    error(e) {\n        if (!br(this)) throw mr(\"error\");\n        var t;\n        t = e, cr(this._controlledTransformStream, t);\n    }\n    terminate() {\n        if (!br(this)) throw mr(\"terminate\");\n        !function(e) {\n            const t = e._controlledTransformStream;\n            gr(t) && wr(t);\n            const r = new TypeError(\"TransformStream terminated\");\n            dr(t, r);\n        }(this);\n    }\n}\nfunction br(e) {\n    return !!r(e) && !!Object.prototype.hasOwnProperty.call(e, \"_controlledTransformStream\") && e instanceof TransformStreamDefaultController;\n}\nfunction hr(e) {\n    e._transformAlgorithm = void 0, e._flushAlgorithm = void 0;\n}\nfunction _r(e, t) {\n    const r = e._controlledTransformStream;\n    if (!gr(r)) throw new TypeError(\"Readable side is not in a state that permits enqueue\");\n    try {\n        !function(e, t) {\n            e._readablePulling = !1;\n            try {\n                e._readableController.enqueue(t);\n            } catch (t) {\n                throw Sr(e, t), t;\n            }\n        }(r, t);\n    } catch (e) {\n        throw dr(r, e), r._readableStoredError;\n    }\n    const o = function(e) {\n        return !function(e) {\n            if (!gr(e)) return !1;\n            if (e._readablePulling) return !0;\n            if (vr(e) > 0) return !0;\n            return !1;\n        }(e);\n    }(r);\n    o !== r._backpressure && fr(r, !0);\n}\nfunction pr(e, t) {\n    return p(e._transformAlgorithm(t), void 0, (t)=>{\n        throw cr(e._controlledTransformStream, t), t;\n    });\n}\nfunction mr(e) {\n    return new TypeError(`TransformStreamDefaultController.prototype.${e} can only be used on a TransformStreamDefaultController`);\n}\nfunction yr(e) {\n    return new TypeError(`TransformStream.prototype.${e} can only be used on a TransformStream`);\n}\nfunction gr(e) {\n    return !e._readableCloseRequested && \"readable\" === e._readableState;\n}\nfunction wr(e) {\n    e._readableState = \"closed\", e._readableCloseRequested = !0, e._readableController.close();\n}\nfunction Sr(e, t) {\n    \"readable\" === e._readableState && (e._readableState = \"errored\", e._readableStoredError = t), e._readableController.error(t);\n}\nfunction vr(e) {\n    return e._readableController.desiredSize;\n}\nfunction Rr(e, t) {\n    \"writable\" !== e._writableState ? qr(e) : Tr(e, t);\n}\nfunction Tr(e, t) {\n    e._writableState = \"erroring\", e._writableStoredError = t, !function(e) {\n        return e._writableHasInFlightOperation;\n    }(e) && e._writableStarted && qr(e);\n}\nfunction qr(e) {\n    e._writableState = \"errored\";\n}\nfunction Cr(e) {\n    \"erroring\" === e._writableState && qr(e);\n}\nObject.defineProperties(TransformStreamDefaultController.prototype, {\n    enqueue: {\n        enumerable: !0\n    },\n    error: {\n        enumerable: !0\n    },\n    terminate: {\n        enumerable: !0\n    },\n    desiredSize: {\n        enumerable: !0\n    }\n}), n(TransformStreamDefaultController.prototype.enqueue, \"enqueue\"), n(TransformStreamDefaultController.prototype.error, \"error\"), n(TransformStreamDefaultController.prototype.terminate, \"terminate\"), \"symbol\" == typeof e.toStringTag && Object.defineProperty(TransformStreamDefaultController.prototype, e.toStringTag, {\n    value: \"TransformStreamDefaultController\",\n    configurable: !0\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL3dlYi1zdHJlYW1zLXBvbHlmaWxsL2Rpc3QvcG9ueWZpbGwubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7O0NBTUMsR0FDRCxNQUFNQSxJQUFFLGNBQVksT0FBT0MsVUFBUSxZQUFVLE9BQU9BLE9BQU9DLFFBQVEsR0FBQ0QsU0FBT0QsQ0FBQUEsSUFBRyxDQUFDLE9BQU8sRUFBRUEsRUFBRSxDQUFDLENBQUM7QUFBQyxTQUFTRyxLQUFJO0FBQUMsU0FBU0MsRUFBRUosQ0FBQztJQUFFLE9BQU0sWUFBVSxPQUFPQSxLQUFHLFNBQU9BLEtBQUcsY0FBWSxPQUFPQTtBQUFDO0FBQUMsTUFBTUssSUFBRUY7QUFBRSxTQUFTRyxFQUFFTixDQUFDLEVBQUNHLENBQUM7SUFBRSxJQUFHO1FBQUNJLE9BQU9DLGNBQWMsQ0FBQ1IsR0FBRSxRQUFPO1lBQUNTLE9BQU1OO1lBQUVPLGNBQWEsQ0FBQztRQUFDO0lBQUUsRUFBQyxPQUFNVixHQUFFLENBQUM7QUFBQztBQUFDLE1BQU1XLElBQUVDLFNBQVFDLElBQUVELFFBQVFFLFNBQVMsQ0FBQ0MsSUFBSSxFQUFDQyxJQUFFSixRQUFRSyxPQUFPLENBQUNDLElBQUksQ0FBQ1AsSUFBR1EsSUFBRVAsUUFBUVEsTUFBTSxDQUFDRixJQUFJLENBQUNQO0FBQUcsU0FBU1UsRUFBRXJCLENBQUM7SUFBRSxPQUFPLElBQUlXLEVBQUVYO0FBQUU7QUFBQyxTQUFTc0IsRUFBRXRCLENBQUM7SUFBRSxPQUFPZ0IsRUFBRWhCO0FBQUU7QUFBQyxTQUFTdUIsRUFBRXZCLENBQUM7SUFBRSxPQUFPbUIsRUFBRW5CO0FBQUU7QUFBQyxTQUFTd0IsRUFBRXhCLENBQUMsRUFBQ0csQ0FBQyxFQUFDQyxDQUFDO0lBQUUsT0FBT1MsRUFBRVksSUFBSSxDQUFDekIsR0FBRUcsR0FBRUM7QUFBRTtBQUFDLFNBQVNzQixFQUFFMUIsQ0FBQyxFQUFDRyxDQUFDLEVBQUNDLENBQUM7SUFB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Q0FBQztJQUFDO0lBQUUwUixXQUFVO1FBQUMxUixZQUFXLENBQUM7SUFBQztJQUFFc0QsYUFBWTtRQUFDdEQsWUFBVyxDQUFDO0lBQUM7QUFBQyxJQUFHaEgsRUFBRWdZLGlDQUFpQ3hYLFNBQVMsQ0FBQ3FLLE9BQU8sRUFBQyxZQUFXN0ssRUFBRWdZLGlDQUFpQ3hYLFNBQVMsQ0FBQytLLEtBQUssRUFBQyxVQUFTdkwsRUFBRWdZLGlDQUFpQ3hYLFNBQVMsQ0FBQ2tZLFNBQVMsRUFBQyxjQUFhLFlBQVUsT0FBT2haLEVBQUV1SCxXQUFXLElBQUVoSCxPQUFPQyxjQUFjLENBQUM4WCxpQ0FBaUN4WCxTQUFTLEVBQUNkLEVBQUV1SCxXQUFXLEVBQUM7SUFBQzlHLE9BQU07SUFBbUNDLGNBQWEsQ0FBQztBQUFDO0FBQWlWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGhlcmFweS1ib3Qtd2ViLy4uL25vZGVfbW9kdWxlcy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9kaXN0L3BvbnlmaWxsLm1qcz8zYWYxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIHdlYi1zdHJlYW1zLXBvbHlmaWxsIHY0LjAuMC1iZXRhLjNcbiAqIENvcHlyaWdodCAyMDIxIE1hdHRpYXMgQnVlbGVucywgRGl3YW5rIFNpbmdoIFRvbWVyIGFuZCBvdGhlciBjb250cmlidXRvcnMuXG4gKiBUaGlzIGNvZGUgaXMgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuICovXG5jb25zdCBlPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9TeW1ib2w6ZT0+YFN5bWJvbCgke2V9KWA7ZnVuY3Rpb24gdCgpe31mdW5jdGlvbiByKGUpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiBlJiZudWxsIT09ZXx8XCJmdW5jdGlvblwiPT10eXBlb2YgZX1jb25zdCBvPXQ7ZnVuY3Rpb24gbihlLHQpe3RyeXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIm5hbWVcIix7dmFsdWU6dCxjb25maWd1cmFibGU6ITB9KX1jYXRjaChlKXt9fWNvbnN0IGE9UHJvbWlzZSxpPVByb21pc2UucHJvdG90eXBlLnRoZW4sbD1Qcm9taXNlLnJlc29sdmUuYmluZChhKSxzPVByb21pc2UucmVqZWN0LmJpbmQoYSk7ZnVuY3Rpb24gdShlKXtyZXR1cm4gbmV3IGEoZSl9ZnVuY3Rpb24gYyhlKXtyZXR1cm4gbChlKX1mdW5jdGlvbiBkKGUpe3JldHVybiBzKGUpfWZ1bmN0aW9uIGYoZSx0LHIpe3JldHVybiBpLmNhbGwoZSx0LHIpfWZ1bmN0aW9uIGIoZSx0LHIpe2YoZihlLHQsciksdm9pZCAwLG8pfWZ1bmN0aW9uIGgoZSx0KXtiKGUsdCl9ZnVuY3Rpb24gXyhlLHQpe2IoZSx2b2lkIDAsdCl9ZnVuY3Rpb24gcChlLHQscil7cmV0dXJuIGYoZSx0LHIpfWZ1bmN0aW9uIG0oZSl7ZihlLHZvaWQgMCxvKX1sZXQgeT1lPT57aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgcXVldWVNaWNyb3Rhc2speT1xdWV1ZU1pY3JvdGFzaztlbHNle2NvbnN0IGU9Yyh2b2lkIDApO3k9dD0+ZihlLHQpfXJldHVybiB5KGUpfTtmdW5jdGlvbiBnKGUsdCxyKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBpcyBub3QgYSBmdW5jdGlvblwiKTtyZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoZSx0LHIpfWZ1bmN0aW9uIHcoZSx0LHIpe3RyeXtyZXR1cm4gYyhnKGUsdCxyKSl9Y2F0Y2goZSl7cmV0dXJuIGQoZSl9fWNsYXNzIFN7Y29uc3RydWN0b3IoKXt0aGlzLl9jdXJzb3I9MCx0aGlzLl9zaXplPTAsdGhpcy5fZnJvbnQ9e19lbGVtZW50czpbXSxfbmV4dDp2b2lkIDB9LHRoaXMuX2JhY2s9dGhpcy5fZnJvbnQsdGhpcy5fY3Vyc29yPTAsdGhpcy5fc2l6ZT0wfWdldCBsZW5ndGgoKXtyZXR1cm4gdGhpcy5fc2l6ZX1wdXNoKGUpe2NvbnN0IHQ9dGhpcy5fYmFjaztsZXQgcj10OzE2MzgzPT09dC5fZWxlbWVudHMubGVuZ3RoJiYocj17X2VsZW1lbnRzOltdLF9uZXh0OnZvaWQgMH0pLHQuX2VsZW1lbnRzLnB1c2goZSksciE9PXQmJih0aGlzLl9iYWNrPXIsdC5fbmV4dD1yKSwrK3RoaXMuX3NpemV9c2hpZnQoKXtjb25zdCBlPXRoaXMuX2Zyb250O2xldCB0PWU7Y29uc3Qgcj10aGlzLl9jdXJzb3I7bGV0IG89cisxO2NvbnN0IG49ZS5fZWxlbWVudHMsYT1uW3JdO3JldHVybiAxNjM4ND09PW8mJih0PWUuX25leHQsbz0wKSwtLXRoaXMuX3NpemUsdGhpcy5fY3Vyc29yPW8sZSE9PXQmJih0aGlzLl9mcm9udD10KSxuW3JdPXZvaWQgMCxhfWZvckVhY2goZSl7bGV0IHQ9dGhpcy5fY3Vyc29yLHI9dGhpcy5fZnJvbnQsbz1yLl9lbGVtZW50cztmb3IoOyEodD09PW8ubGVuZ3RoJiZ2b2lkIDA9PT1yLl9uZXh0fHx0PT09by5sZW5ndGgmJihyPXIuX25leHQsbz1yLl9lbGVtZW50cyx0PTAsMD09PW8ubGVuZ3RoKSk7KWUob1t0XSksKyt0fXBlZWsoKXtjb25zdCBlPXRoaXMuX2Zyb250LHQ9dGhpcy5fY3Vyc29yO3JldHVybiBlLl9lbGVtZW50c1t0XX19Y29uc3Qgdj1lKFwiW1tBYm9ydFN0ZXBzXV1cIiksUj1lKFwiW1tFcnJvclN0ZXBzXV1cIiksVD1lKFwiW1tDYW5jZWxTdGVwc11dXCIpLHE9ZShcIltbUHVsbFN0ZXBzXV1cIiksQz1lKFwiW1tSZWxlYXNlU3RlcHNdXVwiKTtmdW5jdGlvbiBFKGUsdCl7ZS5fb3duZXJSZWFkYWJsZVN0cmVhbT10LHQuX3JlYWRlcj1lLFwicmVhZGFibGVcIj09PXQuX3N0YXRlP08oZSk6XCJjbG9zZWRcIj09PXQuX3N0YXRlP2Z1bmN0aW9uKGUpe08oZSksaihlKX0oZSk6QihlLHQuX3N0b3JlZEVycm9yKX1mdW5jdGlvbiBQKGUsdCl7cmV0dXJuIEd0KGUuX293bmVyUmVhZGFibGVTdHJlYW0sdCl9ZnVuY3Rpb24gVyhlKXtjb25zdCB0PWUuX293bmVyUmVhZGFibGVTdHJlYW07XCJyZWFkYWJsZVwiPT09dC5fc3RhdGU/QShlLG5ldyBUeXBlRXJyb3IoXCJSZWFkZXIgd2FzIHJlbGVhc2VkIGFuZCBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgdG8gbW9uaXRvciB0aGUgc3RyZWFtJ3MgY2xvc2VkbmVzc1wiKSk6ZnVuY3Rpb24oZSx0KXtCKGUsdCl9KGUsbmV3IFR5cGVFcnJvcihcIlJlYWRlciB3YXMgcmVsZWFzZWQgYW5kIGNhbiBubyBsb25nZXIgYmUgdXNlZCB0byBtb25pdG9yIHRoZSBzdHJlYW0ncyBjbG9zZWRuZXNzXCIpKSx0Ll9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXJbQ10oKSx0Ll9yZWFkZXI9dm9pZCAwLGUuX293bmVyUmVhZGFibGVTdHJlYW09dm9pZCAwfWZ1bmN0aW9uIGsoZSl7cmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIrZStcIiBhIHN0cmVhbSB1c2luZyBhIHJlbGVhc2VkIHJlYWRlclwiKX1mdW5jdGlvbiBPKGUpe2UuX2Nsb3NlZFByb21pc2U9dSgoKHQscik9PntlLl9jbG9zZWRQcm9taXNlX3Jlc29sdmU9dCxlLl9jbG9zZWRQcm9taXNlX3JlamVjdD1yfSkpfWZ1bmN0aW9uIEIoZSx0KXtPKGUpLEEoZSx0KX1mdW5jdGlvbiBBKGUsdCl7dm9pZCAwIT09ZS5fY2xvc2VkUHJvbWlzZV9yZWplY3QmJihtKGUuX2Nsb3NlZFByb21pc2UpLGUuX2Nsb3NlZFByb21pc2VfcmVqZWN0KHQpLGUuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZT12b2lkIDAsZS5fY2xvc2VkUHJvbWlzZV9yZWplY3Q9dm9pZCAwKX1mdW5jdGlvbiBqKGUpe3ZvaWQgMCE9PWUuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSYmKGUuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSh2b2lkIDApLGUuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZT12b2lkIDAsZS5fY2xvc2VkUHJvbWlzZV9yZWplY3Q9dm9pZCAwKX1jb25zdCB6PU51bWJlci5pc0Zpbml0ZXx8ZnVuY3Rpb24oZSl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIGUmJmlzRmluaXRlKGUpfSxMPU1hdGgudHJ1bmN8fGZ1bmN0aW9uKGUpe3JldHVybiBlPDA/TWF0aC5jZWlsKGUpOk1hdGguZmxvb3IoZSl9O2Z1bmN0aW9uIEYoZSx0KXtpZih2b2lkIDAhPT1lJiYoXCJvYmplY3RcIiE9dHlwZW9mKHI9ZSkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHIpKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7dH0gaXMgbm90IGFuIG9iamVjdC5gKTt2YXIgcn1mdW5jdGlvbiBJKGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKGAke3R9IGlzIG5vdCBhIGZ1bmN0aW9uLmApfWZ1bmN0aW9uIEQoZSx0KXtpZighZnVuY3Rpb24oZSl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIGUmJm51bGwhPT1lfHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBlfShlKSl0aHJvdyBuZXcgVHlwZUVycm9yKGAke3R9IGlzIG5vdCBhbiBvYmplY3QuYCl9ZnVuY3Rpb24gJChlLHQscil7aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJHt0fSBpcyByZXF1aXJlZCBpbiAnJHtyfScuYCl9ZnVuY3Rpb24gTShlLHQscil7aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKGAke3R9IGlzIHJlcXVpcmVkIGluICcke3J9Jy5gKX1mdW5jdGlvbiBZKGUpe3JldHVybiBOdW1iZXIoZSl9ZnVuY3Rpb24gUShlKXtyZXR1cm4gMD09PWU/MDplfWZ1bmN0aW9uIE4oZSx0KXtjb25zdCByPU51bWJlci5NQVhfU0FGRV9JTlRFR0VSO2xldCBvPU51bWJlcihlKTtpZihvPVEobyksIXoobykpdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt0fSBpcyBub3QgYSBmaW5pdGUgbnVtYmVyYCk7aWYobz1mdW5jdGlvbihlKXtyZXR1cm4gUShMKGUpKX0obyksbzwwfHxvPnIpdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt0fSBpcyBvdXRzaWRlIHRoZSBhY2NlcHRlZCByYW5nZSBvZiAwIHRvICR7cn0sIGluY2x1c2l2ZWApO3JldHVybiB6KG8pJiYwIT09bz9vOjB9ZnVuY3Rpb24gSChlKXtpZighcihlKSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlLmdldFJlYWRlcilyZXR1cm4hMTt0cnl7cmV0dXJuXCJib29sZWFuXCI9PXR5cGVvZiBlLmxvY2tlZH1jYXRjaChlKXtyZXR1cm4hMX19ZnVuY3Rpb24geChlKXtpZighcihlKSlyZXR1cm4hMTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlLmdldFdyaXRlcilyZXR1cm4hMTt0cnl7cmV0dXJuXCJib29sZWFuXCI9PXR5cGVvZiBlLmxvY2tlZH1jYXRjaChlKXtyZXR1cm4hMX19ZnVuY3Rpb24gVihlLHQpe2lmKCFWdChlKSl0aHJvdyBuZXcgVHlwZUVycm9yKGAke3R9IGlzIG5vdCBhIFJlYWRhYmxlU3RyZWFtLmApfWZ1bmN0aW9uIFUoZSx0KXtlLl9yZWFkZXIuX3JlYWRSZXF1ZXN0cy5wdXNoKHQpfWZ1bmN0aW9uIEcoZSx0LHIpe2NvbnN0IG89ZS5fcmVhZGVyLl9yZWFkUmVxdWVzdHMuc2hpZnQoKTtyP28uX2Nsb3NlU3RlcHMoKTpvLl9jaHVua1N0ZXBzKHQpfWZ1bmN0aW9uIFgoZSl7cmV0dXJuIGUuX3JlYWRlci5fcmVhZFJlcXVlc3RzLmxlbmd0aH1mdW5jdGlvbiBKKGUpe2NvbnN0IHQ9ZS5fcmVhZGVyO3JldHVybiB2b2lkIDAhPT10JiYhIUsodCl9Y2xhc3MgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVye2NvbnN0cnVjdG9yKGUpe2lmKCQoZSwxLFwiUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyXCIpLFYoZSxcIkZpcnN0IHBhcmFtZXRlclwiKSxVdChlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhpcyBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBsb2NrZWQgZm9yIGV4Y2x1c2l2ZSByZWFkaW5nIGJ5IGFub3RoZXIgcmVhZGVyXCIpO0UodGhpcyxlKSx0aGlzLl9yZWFkUmVxdWVzdHM9bmV3IFN9Z2V0IGNsb3NlZCgpe3JldHVybiBLKHRoaXMpP3RoaXMuX2Nsb3NlZFByb21pc2U6ZChlZShcImNsb3NlZFwiKSl9Y2FuY2VsKGUpe3JldHVybiBLKHRoaXMpP3ZvaWQgMD09PXRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0/ZChrKFwiY2FuY2VsXCIpKTpQKHRoaXMsZSk6ZChlZShcImNhbmNlbFwiKSl9cmVhZCgpe2lmKCFLKHRoaXMpKXJldHVybiBkKGVlKFwicmVhZFwiKSk7aWYodm9pZCAwPT09dGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSlyZXR1cm4gZChrKFwicmVhZCBmcm9tXCIpKTtsZXQgZSx0O2NvbnN0IHI9dSgoKHIsbyk9PntlPXIsdD1vfSkpO3JldHVybiBmdW5jdGlvbihlLHQpe2NvbnN0IHI9ZS5fb3duZXJSZWFkYWJsZVN0cmVhbTtyLl9kaXN0dXJiZWQ9ITAsXCJjbG9zZWRcIj09PXIuX3N0YXRlP3QuX2Nsb3NlU3RlcHMoKTpcImVycm9yZWRcIj09PXIuX3N0YXRlP3QuX2Vycm9yU3RlcHMoci5fc3RvcmVkRXJyb3IpOnIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcltxXSh0KX0odGhpcyx7X2NodW5rU3RlcHM6dD0+ZSh7dmFsdWU6dCxkb25lOiExfSksX2Nsb3NlU3RlcHM6KCk9PmUoe3ZhbHVlOnZvaWQgMCxkb25lOiEwfSksX2Vycm9yU3RlcHM6ZT0+dChlKX0pLHJ9cmVsZWFzZUxvY2soKXtpZighSyh0aGlzKSl0aHJvdyBlZShcInJlbGVhc2VMb2NrXCIpO3ZvaWQgMCE9PXRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0mJmZ1bmN0aW9uKGUpe1coZSk7Y29uc3QgdD1uZXcgVHlwZUVycm9yKFwiUmVhZGVyIHdhcyByZWxlYXNlZFwiKTtaKGUsdCl9KHRoaXMpfX1mdW5jdGlvbiBLKGUpe3JldHVybiEhcihlKSYmKCEhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJfcmVhZFJlcXVlc3RzXCIpJiZlIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKX1mdW5jdGlvbiBaKGUsdCl7Y29uc3Qgcj1lLl9yZWFkUmVxdWVzdHM7ZS5fcmVhZFJlcXVlc3RzPW5ldyBTLHIuZm9yRWFjaCgoZT0+e2UuX2Vycm9yU3RlcHModCl9KSl9ZnVuY3Rpb24gZWUoZSl7cmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUuJHtlfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyYCl9T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLnByb3RvdHlwZSx7Y2FuY2VsOntlbnVtZXJhYmxlOiEwfSxyZWFkOntlbnVtZXJhYmxlOiEwfSxyZWxlYXNlTG9jazp7ZW51bWVyYWJsZTohMH0sY2xvc2VkOntlbnVtZXJhYmxlOiEwfX0pLG4oUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLnByb3RvdHlwZS5jYW5jZWwsXCJjYW5jZWxcIiksbihSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLnJlYWQsXCJyZWFkXCIpLG4oUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLnByb3RvdHlwZS5yZWxlYXNlTG9jayxcInJlbGVhc2VMb2NrXCIpLFwic3ltYm9sXCI9PXR5cGVvZiBlLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLnByb3RvdHlwZSxlLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclwiLGNvbmZpZ3VyYWJsZTohMH0pO2NsYXNzIHRle2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5fb25nb2luZ1Byb21pc2U9dm9pZCAwLHRoaXMuX2lzRmluaXNoZWQ9ITEsdGhpcy5fcmVhZGVyPWUsdGhpcy5fcHJldmVudENhbmNlbD10fW5leHQoKXtjb25zdCBlPSgpPT50aGlzLl9uZXh0U3RlcHMoKTtyZXR1cm4gdGhpcy5fb25nb2luZ1Byb21pc2U9dGhpcy5fb25nb2luZ1Byb21pc2U/cCh0aGlzLl9vbmdvaW5nUHJvbWlzZSxlLGUpOmUoKSx0aGlzLl9vbmdvaW5nUHJvbWlzZX1yZXR1cm4oZSl7Y29uc3QgdD0oKT0+dGhpcy5fcmV0dXJuU3RlcHMoZSk7cmV0dXJuIHRoaXMuX29uZ29pbmdQcm9taXNlP3AodGhpcy5fb25nb2luZ1Byb21pc2UsdCx0KTp0KCl9X25leHRTdGVwcygpe2lmKHRoaXMuX2lzRmluaXNoZWQpcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7dmFsdWU6dm9pZCAwLGRvbmU6ITB9KTtjb25zdCBlPXRoaXMuX3JlYWRlcjtyZXR1cm4gdm9pZCAwPT09ZT9kKGsoXCJpdGVyYXRlXCIpKTpmKGUucmVhZCgpLChlPT57dmFyIHQ7cmV0dXJuIHRoaXMuX29uZ29pbmdQcm9taXNlPXZvaWQgMCxlLmRvbmUmJih0aGlzLl9pc0ZpbmlzaGVkPSEwLG51bGw9PT0odD10aGlzLl9yZWFkZXIpfHx2b2lkIDA9PT10fHx0LnJlbGVhc2VMb2NrKCksdGhpcy5fcmVhZGVyPXZvaWQgMCksZX0pLChlPT57dmFyIHQ7dGhyb3cgdGhpcy5fb25nb2luZ1Byb21pc2U9dm9pZCAwLHRoaXMuX2lzRmluaXNoZWQ9ITAsbnVsbD09PSh0PXRoaXMuX3JlYWRlcil8fHZvaWQgMD09PXR8fHQucmVsZWFzZUxvY2soKSx0aGlzLl9yZWFkZXI9dm9pZCAwLGV9KSl9X3JldHVyblN0ZXBzKGUpe2lmKHRoaXMuX2lzRmluaXNoZWQpcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7dmFsdWU6ZSxkb25lOiEwfSk7dGhpcy5faXNGaW5pc2hlZD0hMDtjb25zdCB0PXRoaXMuX3JlYWRlcjtpZih2b2lkIDA9PT10KXJldHVybiBkKGsoXCJmaW5pc2ggaXRlcmF0aW5nXCIpKTtpZih0aGlzLl9yZWFkZXI9dm9pZCAwLCF0aGlzLl9wcmV2ZW50Q2FuY2VsKXtjb25zdCByPXQuY2FuY2VsKGUpO3JldHVybiB0LnJlbGVhc2VMb2NrKCkscChyLCgoKT0+KHt2YWx1ZTplLGRvbmU6ITB9KSkpfXJldHVybiB0LnJlbGVhc2VMb2NrKCksYyh7dmFsdWU6ZSxkb25lOiEwfSl9fWNvbnN0IHJlPXtuZXh0KCl7cmV0dXJuIG9lKHRoaXMpP3RoaXMuX2FzeW5jSXRlcmF0b3JJbXBsLm5leHQoKTpkKG5lKFwibmV4dFwiKSl9LHJldHVybihlKXtyZXR1cm4gb2UodGhpcyk/dGhpcy5fYXN5bmNJdGVyYXRvckltcGwucmV0dXJuKGUpOmQobmUoXCJyZXR1cm5cIikpfX07ZnVuY3Rpb24gb2UoZSl7aWYoIXIoZSkpcmV0dXJuITE7aWYoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLFwiX2FzeW5jSXRlcmF0b3JJbXBsXCIpKXJldHVybiExO3RyeXtyZXR1cm4gZS5fYXN5bmNJdGVyYXRvckltcGwgaW5zdGFuY2VvZiB0ZX1jYXRjaChlKXtyZXR1cm4hMX19ZnVuY3Rpb24gbmUoZSl7cmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvci4ke2V9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0ZWFtQXN5bmNJdGVyYXRvcmApfVwic3ltYm9sXCI9PXR5cGVvZiBlLmFzeW5jSXRlcmF0b3ImJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZSxlLmFzeW5jSXRlcmF0b3Ise3ZhbHVlKCl7cmV0dXJuIHRoaXN9LHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pO2NvbnN0IGFlPU51bWJlci5pc05hTnx8ZnVuY3Rpb24oZSl7cmV0dXJuIGUhPWV9O2Z1bmN0aW9uIGllKGUsdCxyLG8sbil7bmV3IFVpbnQ4QXJyYXkoZSkuc2V0KG5ldyBVaW50OEFycmF5KHIsbyxuKSx0KX1mdW5jdGlvbiBsZShlKXtjb25zdCB0PWZ1bmN0aW9uKGUsdCxyKXtpZihlLnNsaWNlKXJldHVybiBlLnNsaWNlKHQscik7Y29uc3Qgbz1yLXQsbj1uZXcgQXJyYXlCdWZmZXIobyk7cmV0dXJuIGllKG4sMCxlLHQsbyksbn0oZS5idWZmZXIsZS5ieXRlT2Zmc2V0LGUuYnl0ZU9mZnNldCtlLmJ5dGVMZW5ndGgpO3JldHVybiBuZXcgVWludDhBcnJheSh0KX1mdW5jdGlvbiBzZShlKXtjb25zdCB0PWUuX3F1ZXVlLnNoaWZ0KCk7cmV0dXJuIGUuX3F1ZXVlVG90YWxTaXplLT10LnNpemUsZS5fcXVldWVUb3RhbFNpemU8MCYmKGUuX3F1ZXVlVG90YWxTaXplPTApLHQudmFsdWV9ZnVuY3Rpb24gdWUoZSx0LHIpe2lmKFwibnVtYmVyXCIhPXR5cGVvZihvPXIpfHxhZShvKXx8bzwwfHxyPT09MS8wKXRocm93IG5ldyBSYW5nZUVycm9yKFwiU2l6ZSBtdXN0IGJlIGEgZmluaXRlLCBub24tTmFOLCBub24tbmVnYXRpdmUgbnVtYmVyLlwiKTt2YXIgbztlLl9xdWV1ZS5wdXNoKHt2YWx1ZTp0LHNpemU6cn0pLGUuX3F1ZXVlVG90YWxTaXplKz1yfWZ1bmN0aW9uIGNlKGUpe2UuX3F1ZXVlPW5ldyBTLGUuX3F1ZXVlVG90YWxTaXplPTB9Y2xhc3MgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdHtjb25zdHJ1Y3Rvcigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGNvbnN0cnVjdG9yXCIpfWdldCB2aWV3KCl7aWYoIWZlKHRoaXMpKXRocm93IEJlKFwidmlld1wiKTtyZXR1cm4gdGhpcy5fdmlld31yZXNwb25kKGUpe2lmKCFmZSh0aGlzKSl0aHJvdyBCZShcInJlc3BvbmRcIik7aWYoJChlLDEsXCJyZXNwb25kXCIpLGU9TihlLFwiRmlyc3QgcGFyYW1ldGVyXCIpLHZvaWQgMD09PXRoaXMuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGlzIEJZT0IgcmVxdWVzdCBoYXMgYmVlbiBpbnZhbGlkYXRlZFwiKTt0aGlzLl92aWV3LmJ1ZmZlcixmdW5jdGlvbihlLHQpe2NvbnN0IHI9ZS5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7aWYoXCJjbG9zZWRcIj09PWUuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlKXtpZigwIT09dCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYnl0ZXNXcml0dGVuIG11c3QgYmUgMCB3aGVuIGNhbGxpbmcgcmVzcG9uZCgpIG9uIGEgY2xvc2VkIHN0cmVhbVwiKX1lbHNle2lmKDA9PT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJieXRlc1dyaXR0ZW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gMCB3aGVuIGNhbGxpbmcgcmVzcG9uZCgpIG9uIGEgcmVhZGFibGUgc3RyZWFtXCIpO2lmKHIuYnl0ZXNGaWxsZWQrdD5yLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJieXRlc1dyaXR0ZW4gb3V0IG9mIHJhbmdlXCIpfXIuYnVmZmVyPXIuYnVmZmVyLHFlKGUsdCl9KHRoaXMuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLGUpfXJlc3BvbmRXaXRoTmV3VmlldyhlKXtpZighZmUodGhpcykpdGhyb3cgQmUoXCJyZXNwb25kV2l0aE5ld1ZpZXdcIik7aWYoJChlLDEsXCJyZXNwb25kV2l0aE5ld1ZpZXdcIiksIUFycmF5QnVmZmVyLmlzVmlldyhlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IGNhbiBvbmx5IHJlc3BvbmQgd2l0aCBhcnJheSBidWZmZXIgdmlld3NcIik7aWYodm9pZCAwPT09dGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoaXMgQllPQiByZXF1ZXN0IGhhcyBiZWVuIGludmFsaWRhdGVkXCIpO2UuYnVmZmVyLGZ1bmN0aW9uKGUsdCl7Y29uc3Qgcj1lLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtpZihcImNsb3NlZFwiPT09ZS5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGUpe2lmKDAhPT10LmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSB2aWV3J3MgbGVuZ3RoIG11c3QgYmUgMCB3aGVuIGNhbGxpbmcgcmVzcG9uZFdpdGhOZXdWaWV3KCkgb24gYSBjbG9zZWQgc3RyZWFtXCIpfWVsc2UgaWYoMD09PXQuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIHZpZXcncyBsZW5ndGggbXVzdCBiZSBncmVhdGVyIHRoYW4gMCB3aGVuIGNhbGxpbmcgcmVzcG9uZFdpdGhOZXdWaWV3KCkgb24gYSByZWFkYWJsZSBzdHJlYW1cIik7aWYoci5ieXRlT2Zmc2V0K3IuYnl0ZXNGaWxsZWQhPT10LmJ5dGVPZmZzZXQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgcmVnaW9uIHNwZWNpZmllZCBieSB2aWV3IGRvZXMgbm90IG1hdGNoIGJ5b2JSZXF1ZXN0XCIpO2lmKHIuYnVmZmVyQnl0ZUxlbmd0aCE9PXQuYnVmZmVyLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgYnVmZmVyIG9mIHZpZXcgaGFzIGRpZmZlcmVudCBjYXBhY2l0eSB0aGFuIGJ5b2JSZXF1ZXN0XCIpO2lmKHIuYnl0ZXNGaWxsZWQrdC5ieXRlTGVuZ3RoPnIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSByZWdpb24gc3BlY2lmaWVkIGJ5IHZpZXcgaXMgbGFyZ2VyIHRoYW4gYnlvYlJlcXVlc3RcIik7Y29uc3Qgbz10LmJ5dGVMZW5ndGg7ci5idWZmZXI9dC5idWZmZXIscWUoZSxvKX0odGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsZSl9fU9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlLHtyZXNwb25kOntlbnVtZXJhYmxlOiEwfSxyZXNwb25kV2l0aE5ld1ZpZXc6e2VudW1lcmFibGU6ITB9LHZpZXc6e2VudW1lcmFibGU6ITB9fSksbihSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZS5yZXNwb25kLFwicmVzcG9uZFwiKSxuKFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlLnJlc3BvbmRXaXRoTmV3VmlldyxcInJlc3BvbmRXaXRoTmV3Vmlld1wiKSxcInN5bWJvbFwiPT10eXBlb2YgZS50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlLGUudG9TdHJpbmdUYWcse3ZhbHVlOlwiUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdFwiLGNvbmZpZ3VyYWJsZTohMH0pO2NsYXNzIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJ7Y29uc3RydWN0b3IoKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBjb25zdHJ1Y3RvclwiKX1nZXQgYnlvYlJlcXVlc3QoKXtpZighZGUodGhpcykpdGhyb3cgQWUoXCJieW9iUmVxdWVzdFwiKTtyZXR1cm4gZnVuY3Rpb24oZSl7aWYobnVsbD09PWUuX2J5b2JSZXF1ZXN0JiZlLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aD4wKXtjb25zdCB0PWUuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpLHI9bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsdC5ieXRlT2Zmc2V0K3QuYnl0ZXNGaWxsZWQsdC5ieXRlTGVuZ3RoLXQuYnl0ZXNGaWxsZWQpLG89T2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZSk7IWZ1bmN0aW9uKGUsdCxyKXtlLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcj10LGUuX3ZpZXc9cn0obyxlLHIpLGUuX2J5b2JSZXF1ZXN0PW99cmV0dXJuIGUuX2J5b2JSZXF1ZXN0fSh0aGlzKX1nZXQgZGVzaXJlZFNpemUoKXtpZighZGUodGhpcykpdGhyb3cgQWUoXCJkZXNpcmVkU2l6ZVwiKTtyZXR1cm4ga2UodGhpcyl9Y2xvc2UoKXtpZighZGUodGhpcykpdGhyb3cgQWUoXCJjbG9zZVwiKTtpZih0aGlzLl9jbG9zZVJlcXVlc3RlZCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIHN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZDsgZG8gbm90IGNsb3NlIGl0IGFnYWluIVwiKTtjb25zdCBlPXRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO2lmKFwicmVhZGFibGVcIiE9PWUpdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIHN0cmVhbSAoaW4gJHtlfSBzdGF0ZSkgaXMgbm90IGluIHRoZSByZWFkYWJsZSBzdGF0ZSBhbmQgY2Fubm90IGJlIGNsb3NlZGApOyFmdW5jdGlvbihlKXtjb25zdCB0PWUuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07aWYoZS5fY2xvc2VSZXF1ZXN0ZWR8fFwicmVhZGFibGVcIiE9PXQuX3N0YXRlKXJldHVybjtpZihlLl9xdWV1ZVRvdGFsU2l6ZT4wKXJldHVybiB2b2lkKGUuX2Nsb3NlUmVxdWVzdGVkPSEwKTtpZihlLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aD4wKXtpZihlLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKS5ieXRlc0ZpbGxlZD4wKXtjb25zdCB0PW5ldyBUeXBlRXJyb3IoXCJJbnN1ZmZpY2llbnQgYnl0ZXMgdG8gZmlsbCBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gYnVmZmVyXCIpO3Rocm93IFBlKGUsdCksdH19RWUoZSksWHQodCl9KHRoaXMpfWVucXVldWUoZSl7aWYoIWRlKHRoaXMpKXRocm93IEFlKFwiZW5xdWV1ZVwiKTtpZigkKGUsMSxcImVucXVldWVcIiksIUFycmF5QnVmZmVyLmlzVmlldyhlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2h1bmsgbXVzdCBiZSBhbiBhcnJheSBidWZmZXIgdmlld1wiKTtpZigwPT09ZS5ieXRlTGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoXCJjaHVuayBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aFwiKTtpZigwPT09ZS5idWZmZXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2h1bmsncyBidWZmZXIgbXVzdCBoYXZlIG5vbi16ZXJvIGJ5dGVMZW5ndGhcIik7aWYodGhpcy5fY2xvc2VSZXF1ZXN0ZWQpdGhyb3cgbmV3IFR5cGVFcnJvcihcInN0cmVhbSBpcyBjbG9zZWQgb3IgZHJhaW5pbmdcIik7Y29uc3QgdD10aGlzLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtpZihcInJlYWRhYmxlXCIhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBzdHJlYW0gKGluICR7dH0gc3RhdGUpIGlzIG5vdCBpbiB0aGUgcmVhZGFibGUgc3RhdGUgYW5kIGNhbm5vdCBiZSBlbnF1ZXVlZCB0b2ApOyFmdW5jdGlvbihlLHQpe2NvbnN0IHI9ZS5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtpZihlLl9jbG9zZVJlcXVlc3RlZHx8XCJyZWFkYWJsZVwiIT09ci5fc3RhdGUpcmV0dXJuO2NvbnN0IG89dC5idWZmZXIsbj10LmJ5dGVPZmZzZXQsYT10LmJ5dGVMZW5ndGgsaT1vO2lmKGUuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoPjApe2NvbnN0IHQ9ZS5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7dC5idWZmZXIsMCxSZShlKSx0LmJ1ZmZlcj10LmJ1ZmZlcixcIm5vbmVcIj09PXQucmVhZGVyVHlwZSYmZ2UoZSx0KX1pZihKKHIpKWlmKGZ1bmN0aW9uKGUpe2NvbnN0IHQ9ZS5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fcmVhZGVyO2Zvcig7dC5fcmVhZFJlcXVlc3RzLmxlbmd0aD4wOyl7aWYoMD09PWUuX3F1ZXVlVG90YWxTaXplKXJldHVybjtXZShlLHQuX3JlYWRSZXF1ZXN0cy5zaGlmdCgpKX19KGUpLDA9PT1YKHIpKW1lKGUsaSxuLGEpO2Vsc2V7ZS5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGg+MCYmQ2UoZSk7RyhyLG5ldyBVaW50OEFycmF5KGksbixhKSwhMSl9ZWxzZSBMZShyKT8obWUoZSxpLG4sYSksVGUoZSkpOm1lKGUsaSxuLGEpO2JlKGUpfSh0aGlzLGUpfWVycm9yKGUpe2lmKCFkZSh0aGlzKSl0aHJvdyBBZShcImVycm9yXCIpO1BlKHRoaXMsZSl9W1RdKGUpe2hlKHRoaXMpLGNlKHRoaXMpO2NvbnN0IHQ9dGhpcy5fY2FuY2VsQWxnb3JpdGhtKGUpO3JldHVybiBFZSh0aGlzKSx0fVtxXShlKXtjb25zdCB0PXRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07aWYodGhpcy5fcXVldWVUb3RhbFNpemU+MClyZXR1cm4gdm9pZCBXZSh0aGlzLGUpO2NvbnN0IHI9dGhpcy5fYXV0b0FsbG9jYXRlQ2h1bmtTaXplO2lmKHZvaWQgMCE9PXIpe2xldCB0O3RyeXt0PW5ldyBBcnJheUJ1ZmZlcihyKX1jYXRjaCh0KXtyZXR1cm4gdm9pZCBlLl9lcnJvclN0ZXBzKHQpfWNvbnN0IG89e2J1ZmZlcjp0LGJ1ZmZlckJ5dGVMZW5ndGg6cixieXRlT2Zmc2V0OjAsYnl0ZUxlbmd0aDpyLGJ5dGVzRmlsbGVkOjAsZWxlbWVudFNpemU6MSx2aWV3Q29uc3RydWN0b3I6VWludDhBcnJheSxyZWFkZXJUeXBlOlwiZGVmYXVsdFwifTt0aGlzLl9wZW5kaW5nUHVsbEludG9zLnB1c2gobyl9VSh0LGUpLGJlKHRoaXMpfVtDXSgpe2lmKHRoaXMuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoPjApe2NvbnN0IGU9dGhpcy5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7ZS5yZWFkZXJUeXBlPVwibm9uZVwiLHRoaXMuX3BlbmRpbmdQdWxsSW50b3M9bmV3IFMsdGhpcy5fcGVuZGluZ1B1bGxJbnRvcy5wdXNoKGUpfX19ZnVuY3Rpb24gZGUoZSl7cmV0dXJuISFyKGUpJiYoISFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxcIl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtXCIpJiZlIGluc3RhbmNlb2YgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcil9ZnVuY3Rpb24gZmUoZSl7cmV0dXJuISFyKGUpJiYoISFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxcIl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclwiKSYmZSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QpfWZ1bmN0aW9uIGJlKGUpe2NvbnN0IHQ9ZnVuY3Rpb24oZSl7Y29uc3QgdD1lLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO2lmKFwicmVhZGFibGVcIiE9PXQuX3N0YXRlKXJldHVybiExO2lmKGUuX2Nsb3NlUmVxdWVzdGVkKXJldHVybiExO2lmKCFlLl9zdGFydGVkKXJldHVybiExO2lmKEoodCkmJlgodCk+MClyZXR1cm4hMDtpZihMZSh0KSYmemUodCk+MClyZXR1cm4hMDtpZihrZShlKT4wKXJldHVybiEwO3JldHVybiExfShlKTtpZighdClyZXR1cm47aWYoZS5fcHVsbGluZylyZXR1cm4gdm9pZChlLl9wdWxsQWdhaW49ITApO2UuX3B1bGxpbmc9ITA7YihlLl9wdWxsQWxnb3JpdGhtKCksKCgpPT4oZS5fcHVsbGluZz0hMSxlLl9wdWxsQWdhaW4mJihlLl9wdWxsQWdhaW49ITEsYmUoZSkpLG51bGwpKSwodD0+KFBlKGUsdCksbnVsbCkpKX1mdW5jdGlvbiBoZShlKXtSZShlKSxlLl9wZW5kaW5nUHVsbEludG9zPW5ldyBTfWZ1bmN0aW9uIF9lKGUsdCl7bGV0IHI9ITE7XCJjbG9zZWRcIj09PWUuX3N0YXRlJiYocj0hMCk7Y29uc3Qgbz1wZSh0KTtcImRlZmF1bHRcIj09PXQucmVhZGVyVHlwZT9HKGUsbyxyKTpmdW5jdGlvbihlLHQscil7Y29uc3Qgbz1lLl9yZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMuc2hpZnQoKTtyP28uX2Nsb3NlU3RlcHModCk6by5fY2h1bmtTdGVwcyh0KX0oZSxvLHIpfWZ1bmN0aW9uIHBlKGUpe2NvbnN0IHQ9ZS5ieXRlc0ZpbGxlZCxyPWUuZWxlbWVudFNpemU7cmV0dXJuIG5ldyBlLnZpZXdDb25zdHJ1Y3RvcihlLmJ1ZmZlcixlLmJ5dGVPZmZzZXQsdC9yKX1mdW5jdGlvbiBtZShlLHQscixvKXtlLl9xdWV1ZS5wdXNoKHtidWZmZXI6dCxieXRlT2Zmc2V0OnIsYnl0ZUxlbmd0aDpvfSksZS5fcXVldWVUb3RhbFNpemUrPW99ZnVuY3Rpb24geWUoZSx0LHIsbyl7bGV0IG47dHJ5e249dC5zbGljZShyLHIrbyl9Y2F0Y2godCl7dGhyb3cgUGUoZSx0KSx0fW1lKGUsbiwwLG8pfWZ1bmN0aW9uIGdlKGUsdCl7dC5ieXRlc0ZpbGxlZD4wJiZ5ZShlLHQuYnVmZmVyLHQuYnl0ZU9mZnNldCx0LmJ5dGVzRmlsbGVkKSxDZShlKX1mdW5jdGlvbiB3ZShlLHQpe2NvbnN0IHI9dC5lbGVtZW50U2l6ZSxvPXQuYnl0ZXNGaWxsZWQtdC5ieXRlc0ZpbGxlZCVyLG49TWF0aC5taW4oZS5fcXVldWVUb3RhbFNpemUsdC5ieXRlTGVuZ3RoLXQuYnl0ZXNGaWxsZWQpLGE9dC5ieXRlc0ZpbGxlZCtuLGk9YS1hJXI7bGV0IGw9bixzPSExO2k+byYmKGw9aS10LmJ5dGVzRmlsbGVkLHM9ITApO2NvbnN0IHU9ZS5fcXVldWU7Zm9yKDtsPjA7KXtjb25zdCByPXUucGVlaygpLG89TWF0aC5taW4obCxyLmJ5dGVMZW5ndGgpLG49dC5ieXRlT2Zmc2V0K3QuYnl0ZXNGaWxsZWQ7aWUodC5idWZmZXIsbixyLmJ1ZmZlcixyLmJ5dGVPZmZzZXQsbyksci5ieXRlTGVuZ3RoPT09bz91LnNoaWZ0KCk6KHIuYnl0ZU9mZnNldCs9byxyLmJ5dGVMZW5ndGgtPW8pLGUuX3F1ZXVlVG90YWxTaXplLT1vLFNlKGUsbyx0KSxsLT1vfXJldHVybiBzfWZ1bmN0aW9uIFNlKGUsdCxyKXtyLmJ5dGVzRmlsbGVkKz10fWZ1bmN0aW9uIHZlKGUpezA9PT1lLl9xdWV1ZVRvdGFsU2l6ZSYmZS5fY2xvc2VSZXF1ZXN0ZWQ/KEVlKGUpLFh0KGUuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0pKTpiZShlKX1mdW5jdGlvbiBSZShlKXtudWxsIT09ZS5fYnlvYlJlcXVlc3QmJihlLl9ieW9iUmVxdWVzdC5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXI9dm9pZCAwLGUuX2J5b2JSZXF1ZXN0Ll92aWV3PW51bGwsZS5fYnlvYlJlcXVlc3Q9bnVsbCl9ZnVuY3Rpb24gVGUoZSl7Zm9yKDtlLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aD4wOyl7aWYoMD09PWUuX3F1ZXVlVG90YWxTaXplKXJldHVybjtjb25zdCB0PWUuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO3dlKGUsdCkmJihDZShlKSxfZShlLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLHQpKX19ZnVuY3Rpb24gcWUoZSx0KXtjb25zdCByPWUuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1JlKGUpO1wiY2xvc2VkXCI9PT1lLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZT9mdW5jdGlvbihlLHQpe1wibm9uZVwiPT09dC5yZWFkZXJUeXBlJiZDZShlKTtjb25zdCByPWUuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07aWYoTGUocikpZm9yKDt6ZShyKT4wOylfZShyLENlKGUpKX0oZSxyKTpmdW5jdGlvbihlLHQscil7aWYoU2UoMCx0LHIpLFwibm9uZVwiPT09ci5yZWFkZXJUeXBlKXJldHVybiBnZShlLHIpLHZvaWQgVGUoZSk7aWYoci5ieXRlc0ZpbGxlZDxyLmVsZW1lbnRTaXplKXJldHVybjtDZShlKTtjb25zdCBvPXIuYnl0ZXNGaWxsZWQlci5lbGVtZW50U2l6ZTtpZihvPjApe2NvbnN0IHQ9ci5ieXRlT2Zmc2V0K3IuYnl0ZXNGaWxsZWQ7eWUoZSxyLmJ1ZmZlcix0LW8sbyl9ci5ieXRlc0ZpbGxlZC09byxfZShlLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLHIpLFRlKGUpfShlLHQsciksYmUoZSl9ZnVuY3Rpb24gQ2UoZSl7cmV0dXJuIGUuX3BlbmRpbmdQdWxsSW50b3Muc2hpZnQoKX1mdW5jdGlvbiBFZShlKXtlLl9wdWxsQWxnb3JpdGhtPXZvaWQgMCxlLl9jYW5jZWxBbGdvcml0aG09dm9pZCAwfWZ1bmN0aW9uIFBlKGUsdCl7Y29uc3Qgcj1lLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1wicmVhZGFibGVcIj09PXIuX3N0YXRlJiYoaGUoZSksY2UoZSksRWUoZSksSnQocix0KSl9ZnVuY3Rpb24gV2UoZSx0KXtjb25zdCByPWUuX3F1ZXVlLnNoaWZ0KCk7ZS5fcXVldWVUb3RhbFNpemUtPXIuYnl0ZUxlbmd0aCx2ZShlKTtjb25zdCBvPW5ldyBVaW50OEFycmF5KHIuYnVmZmVyLHIuYnl0ZU9mZnNldCxyLmJ5dGVMZW5ndGgpO3QuX2NodW5rU3RlcHMobyl9ZnVuY3Rpb24ga2UoZSl7Y29uc3QgdD1lLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtyZXR1cm5cImVycm9yZWRcIj09PXQ/bnVsbDpcImNsb3NlZFwiPT09dD8wOmUuX3N0cmF0ZWd5SFdNLWUuX3F1ZXVlVG90YWxTaXplfWZ1bmN0aW9uIE9lKGUsdCxyKXtjb25zdCBvPU9iamVjdC5jcmVhdGUoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUpO2xldCBuLGEsaTtuPXZvaWQgMCE9PXQuc3RhcnQ/KCk9PnQuc3RhcnQobyk6KCk9Pnt9LGE9dm9pZCAwIT09dC5wdWxsPygpPT50LnB1bGwobyk6KCk9PmModm9pZCAwKSxpPXZvaWQgMCE9PXQuY2FuY2VsP2U9PnQuY2FuY2VsKGUpOigpPT5jKHZvaWQgMCk7Y29uc3QgbD10LmF1dG9BbGxvY2F0ZUNodW5rU2l6ZTtpZigwPT09bCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXV0b0FsbG9jYXRlQ2h1bmtTaXplIG11c3QgYmUgZ3JlYXRlciB0aGFuIDBcIik7IWZ1bmN0aW9uKGUsdCxyLG8sbixhLGkpe3QuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW09ZSx0Ll9wdWxsQWdhaW49ITEsdC5fcHVsbGluZz0hMSx0Ll9ieW9iUmVxdWVzdD1udWxsLHQuX3F1ZXVlPXQuX3F1ZXVlVG90YWxTaXplPXZvaWQgMCxjZSh0KSx0Ll9jbG9zZVJlcXVlc3RlZD0hMSx0Ll9zdGFydGVkPSExLHQuX3N0cmF0ZWd5SFdNPWEsdC5fcHVsbEFsZ29yaXRobT1vLHQuX2NhbmNlbEFsZ29yaXRobT1uLHQuX2F1dG9BbGxvY2F0ZUNodW5rU2l6ZT1pLHQuX3BlbmRpbmdQdWxsSW50b3M9bmV3IFMsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyPXQsYihjKHIoKSksKCgpPT4odC5fc3RhcnRlZD0hMCxiZSh0KSxudWxsKSksKGU9PihQZSh0LGUpLG51bGwpKSl9KGUsbyxuLGEsaSxyLGwpfWZ1bmN0aW9uIEJlKGUpe3JldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZS4ke2V9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0YCl9ZnVuY3Rpb24gQWUoZSl7cmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLiR7ZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJgKX1mdW5jdGlvbiBqZShlLHQpe2UuX3JlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5wdXNoKHQpfWZ1bmN0aW9uIHplKGUpe3JldHVybiBlLl9yZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMubGVuZ3RofWZ1bmN0aW9uIExlKGUpe2NvbnN0IHQ9ZS5fcmVhZGVyO3JldHVybiB2b2lkIDAhPT10JiYhIUZlKHQpfU9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLHtjbG9zZTp7ZW51bWVyYWJsZTohMH0sZW5xdWV1ZTp7ZW51bWVyYWJsZTohMH0sZXJyb3I6e2VudW1lcmFibGU6ITB9LGJ5b2JSZXF1ZXN0OntlbnVtZXJhYmxlOiEwfSxkZXNpcmVkU2l6ZTp7ZW51bWVyYWJsZTohMH19KSxuKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmNsb3NlLFwiY2xvc2VcIiksbihSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5lbnF1ZXVlLFwiZW5xdWV1ZVwiKSxuKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmVycm9yLFwiZXJyb3JcIiksXCJzeW1ib2xcIj09dHlwZW9mIGUudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZSxlLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJcIixjb25maWd1cmFibGU6ITB9KTtjbGFzcyBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJ7Y29uc3RydWN0b3IoZSl7aWYoJChlLDEsXCJSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJcIiksVihlLFwiRmlyc3QgcGFyYW1ldGVyXCIpLFV0KGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGlzIHN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGxvY2tlZCBmb3IgZXhjbHVzaXZlIHJlYWRpbmcgYnkgYW5vdGhlciByZWFkZXJcIik7aWYoIWRlKGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjb25zdHJ1Y3QgYSBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIgZm9yIGEgc3RyZWFtIG5vdCBjb25zdHJ1Y3RlZCB3aXRoIGEgYnl0ZSBzb3VyY2VcIik7RSh0aGlzLGUpLHRoaXMuX3JlYWRJbnRvUmVxdWVzdHM9bmV3IFN9Z2V0IGNsb3NlZCgpe3JldHVybiBGZSh0aGlzKT90aGlzLl9jbG9zZWRQcm9taXNlOmQoRGUoXCJjbG9zZWRcIikpfWNhbmNlbChlKXtyZXR1cm4gRmUodGhpcyk/dm9pZCAwPT09dGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbT9kKGsoXCJjYW5jZWxcIikpOlAodGhpcyxlKTpkKERlKFwiY2FuY2VsXCIpKX1yZWFkKGUpe2lmKCFGZSh0aGlzKSlyZXR1cm4gZChEZShcInJlYWRcIikpO2lmKCFBcnJheUJ1ZmZlci5pc1ZpZXcoZSkpcmV0dXJuIGQobmV3IFR5cGVFcnJvcihcInZpZXcgbXVzdCBiZSBhbiBhcnJheSBidWZmZXIgdmlld1wiKSk7aWYoMD09PWUuYnl0ZUxlbmd0aClyZXR1cm4gZChuZXcgVHlwZUVycm9yKFwidmlldyBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aFwiKSk7aWYoMD09PWUuYnVmZmVyLmJ5dGVMZW5ndGgpcmV0dXJuIGQobmV3IFR5cGVFcnJvcihcInZpZXcncyBidWZmZXIgbXVzdCBoYXZlIG5vbi16ZXJvIGJ5dGVMZW5ndGhcIikpO2lmKGUuYnVmZmVyLHZvaWQgMD09PXRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0pcmV0dXJuIGQoayhcInJlYWQgZnJvbVwiKSk7bGV0IHQscjtjb25zdCBvPXUoKChlLG8pPT57dD1lLHI9b30pKTtyZXR1cm4gZnVuY3Rpb24oZSx0LHIpe2NvbnN0IG89ZS5fb3duZXJSZWFkYWJsZVN0cmVhbTtvLl9kaXN0dXJiZWQ9ITAsXCJlcnJvcmVkXCI9PT1vLl9zdGF0ZT9yLl9lcnJvclN0ZXBzKG8uX3N0b3JlZEVycm9yKTpmdW5jdGlvbihlLHQscil7Y29uc3Qgbz1lLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO2xldCBuPTE7dC5jb25zdHJ1Y3RvciE9PURhdGFWaWV3JiYobj10LmNvbnN0cnVjdG9yLkJZVEVTX1BFUl9FTEVNRU5UKTtjb25zdCBhPXQuY29uc3RydWN0b3IsaT10LmJ1ZmZlcixsPXtidWZmZXI6aSxidWZmZXJCeXRlTGVuZ3RoOmkuYnl0ZUxlbmd0aCxieXRlT2Zmc2V0OnQuYnl0ZU9mZnNldCxieXRlTGVuZ3RoOnQuYnl0ZUxlbmd0aCxieXRlc0ZpbGxlZDowLGVsZW1lbnRTaXplOm4sdmlld0NvbnN0cnVjdG9yOmEscmVhZGVyVHlwZTpcImJ5b2JcIn07aWYoZS5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGg+MClyZXR1cm4gZS5fcGVuZGluZ1B1bGxJbnRvcy5wdXNoKGwpLHZvaWQgamUobyxyKTtpZihcImNsb3NlZFwiIT09by5fc3RhdGUpe2lmKGUuX3F1ZXVlVG90YWxTaXplPjApe2lmKHdlKGUsbCkpe2NvbnN0IHQ9cGUobCk7cmV0dXJuIHZlKGUpLHZvaWQgci5fY2h1bmtTdGVwcyh0KX1pZihlLl9jbG9zZVJlcXVlc3RlZCl7Y29uc3QgdD1uZXcgVHlwZUVycm9yKFwiSW5zdWZmaWNpZW50IGJ5dGVzIHRvIGZpbGwgZWxlbWVudHMgaW4gdGhlIGdpdmVuIGJ1ZmZlclwiKTtyZXR1cm4gUGUoZSx0KSx2b2lkIHIuX2Vycm9yU3RlcHModCl9fWUuX3BlbmRpbmdQdWxsSW50b3MucHVzaChsKSxqZShvLHIpLGJlKGUpfWVsc2V7Y29uc3QgZT1uZXcgYShsLmJ1ZmZlcixsLmJ5dGVPZmZzZXQsMCk7ci5fY2xvc2VTdGVwcyhlKX19KG8uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcix0LHIpfSh0aGlzLGUse19jaHVua1N0ZXBzOmU9PnQoe3ZhbHVlOmUsZG9uZTohMX0pLF9jbG9zZVN0ZXBzOmU9PnQoe3ZhbHVlOmUsZG9uZTohMH0pLF9lcnJvclN0ZXBzOmU9PnIoZSl9KSxvfXJlbGVhc2VMb2NrKCl7aWYoIUZlKHRoaXMpKXRocm93IERlKFwicmVsZWFzZUxvY2tcIik7dm9pZCAwIT09dGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSYmZnVuY3Rpb24oZSl7VyhlKTtjb25zdCB0PW5ldyBUeXBlRXJyb3IoXCJSZWFkZXIgd2FzIHJlbGVhc2VkXCIpO0llKGUsdCl9KHRoaXMpfX1mdW5jdGlvbiBGZShlKXtyZXR1cm4hIXIoZSkmJighIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLFwiX3JlYWRJbnRvUmVxdWVzdHNcIikmJmUgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIpfWZ1bmN0aW9uIEllKGUsdCl7Y29uc3Qgcj1lLl9yZWFkSW50b1JlcXVlc3RzO2UuX3JlYWRJbnRvUmVxdWVzdHM9bmV3IFMsci5mb3JFYWNoKChlPT57ZS5fZXJyb3JTdGVwcyh0KX0pKX1mdW5jdGlvbiBEZShlKXtyZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnByb3RvdHlwZS4ke2V9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJgKX1mdW5jdGlvbiAkZShlLHQpe2NvbnN0e2hpZ2hXYXRlck1hcms6cn09ZTtpZih2b2lkIDA9PT1yKXJldHVybiB0O2lmKGFlKHIpfHxyPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGhpZ2hXYXRlck1hcmtcIik7cmV0dXJuIHJ9ZnVuY3Rpb24gTWUoZSl7Y29uc3R7c2l6ZTp0fT1lO3JldHVybiB0fHwoKCk9PjEpfWZ1bmN0aW9uIFllKGUsdCl7RihlLHQpO2NvbnN0IHI9bnVsbD09ZT92b2lkIDA6ZS5oaWdoV2F0ZXJNYXJrLG89bnVsbD09ZT92b2lkIDA6ZS5zaXplO3JldHVybntoaWdoV2F0ZXJNYXJrOnZvaWQgMD09PXI/dm9pZCAwOlkociksc2l6ZTp2b2lkIDA9PT1vP3ZvaWQgMDpRZShvLGAke3R9IGhhcyBtZW1iZXIgJ3NpemUnIHRoYXRgKX19ZnVuY3Rpb24gUWUoZSx0KXtyZXR1cm4gSShlLHQpLHQ9PlkoZSh0KSl9ZnVuY3Rpb24gTmUoZSx0LHIpe3JldHVybiBJKGUscikscj0+dyhlLHQsW3JdKX1mdW5jdGlvbiBIZShlLHQscil7cmV0dXJuIEkoZSxyKSwoKT0+dyhlLHQsW10pfWZ1bmN0aW9uIHhlKGUsdCxyKXtyZXR1cm4gSShlLHIpLHI9PmcoZSx0LFtyXSl9ZnVuY3Rpb24gVmUoZSx0LHIpe3JldHVybiBJKGUsciksKHIsbyk9PncoZSx0LFtyLG9dKX1PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucHJvdG90eXBlLHtjYW5jZWw6e2VudW1lcmFibGU6ITB9LHJlYWQ6e2VudW1lcmFibGU6ITB9LHJlbGVhc2VMb2NrOntlbnVtZXJhYmxlOiEwfSxjbG9zZWQ6e2VudW1lcmFibGU6ITB9fSksbihSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucHJvdG90eXBlLmNhbmNlbCxcImNhbmNlbFwiKSxuKFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUucmVhZCxcInJlYWRcIiksbihSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucHJvdG90eXBlLnJlbGVhc2VMb2NrLFwicmVsZWFzZUxvY2tcIiksXCJzeW1ib2xcIj09dHlwZW9mIGUudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucHJvdG90eXBlLGUudG9TdHJpbmdUYWcse3ZhbHVlOlwiUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyXCIsY29uZmlndXJhYmxlOiEwfSk7Y29uc3QgVWU9XCJmdW5jdGlvblwiPT10eXBlb2YgQWJvcnRDb250cm9sbGVyO2NsYXNzIFdyaXRhYmxlU3RyZWFte2NvbnN0cnVjdG9yKGU9e30sdD17fSl7dm9pZCAwPT09ZT9lPW51bGw6RChlLFwiRmlyc3QgcGFyYW1ldGVyXCIpO2NvbnN0IHI9WWUodCxcIlNlY29uZCBwYXJhbWV0ZXJcIiksbz1mdW5jdGlvbihlLHQpe0YoZSx0KTtjb25zdCByPW51bGw9PWU/dm9pZCAwOmUuYWJvcnQsbz1udWxsPT1lP3ZvaWQgMDplLmNsb3NlLG49bnVsbD09ZT92b2lkIDA6ZS5zdGFydCxhPW51bGw9PWU/dm9pZCAwOmUudHlwZSxpPW51bGw9PWU/dm9pZCAwOmUud3JpdGU7cmV0dXJue2Fib3J0OnZvaWQgMD09PXI/dm9pZCAwOk5lKHIsZSxgJHt0fSBoYXMgbWVtYmVyICdhYm9ydCcgdGhhdGApLGNsb3NlOnZvaWQgMD09PW8/dm9pZCAwOkhlKG8sZSxgJHt0fSBoYXMgbWVtYmVyICdjbG9zZScgdGhhdGApLHN0YXJ0OnZvaWQgMD09PW4/dm9pZCAwOnhlKG4sZSxgJHt0fSBoYXMgbWVtYmVyICdzdGFydCcgdGhhdGApLHdyaXRlOnZvaWQgMD09PWk/dm9pZCAwOlZlKGksZSxgJHt0fSBoYXMgbWVtYmVyICd3cml0ZScgdGhhdGApLHR5cGU6YX19KGUsXCJGaXJzdCBwYXJhbWV0ZXJcIik7dmFyIG47KG49dGhpcykuX3N0YXRlPVwid3JpdGFibGVcIixuLl9zdG9yZWRFcnJvcj12b2lkIDAsbi5fd3JpdGVyPXZvaWQgMCxuLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXI9dm9pZCAwLG4uX3dyaXRlUmVxdWVzdHM9bmV3IFMsbi5faW5GbGlnaHRXcml0ZVJlcXVlc3Q9dm9pZCAwLG4uX2Nsb3NlUmVxdWVzdD12b2lkIDAsbi5faW5GbGlnaHRDbG9zZVJlcXVlc3Q9dm9pZCAwLG4uX3BlbmRpbmdBYm9ydFJlcXVlc3Q9dm9pZCAwLG4uX2JhY2twcmVzc3VyZT0hMTtpZih2b2lkIDAhPT1vLnR5cGUpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHR5cGUgaXMgc3BlY2lmaWVkXCIpO2NvbnN0IGE9TWUocik7IWZ1bmN0aW9uKGUsdCxyLG8pe2NvbnN0IG49T2JqZWN0LmNyZWF0ZShXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7bGV0IGEsaSxsLHM7YT12b2lkIDAhPT10LnN0YXJ0PygpPT50LnN0YXJ0KG4pOigpPT57fTtpPXZvaWQgMCE9PXQud3JpdGU/ZT0+dC53cml0ZShlLG4pOigpPT5jKHZvaWQgMCk7bD12b2lkIDAhPT10LmNsb3NlPygpPT50LmNsb3NlKCk6KCk9PmModm9pZCAwKTtzPXZvaWQgMCE9PXQuYWJvcnQ/ZT0+dC5hYm9ydChlKTooKT0+Yyh2b2lkIDApOyFmdW5jdGlvbihlLHQscixvLG4sYSxpLGwpe3QuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbT1lLGUuX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcj10LHQuX3F1ZXVlPXZvaWQgMCx0Ll9xdWV1ZVRvdGFsU2l6ZT12b2lkIDAsY2UodCksdC5fYWJvcnRSZWFzb249dm9pZCAwLHQuX2Fib3J0Q29udHJvbGxlcj1mdW5jdGlvbigpe2lmKFVlKXJldHVybiBuZXcgQWJvcnRDb250cm9sbGVyfSgpLHQuX3N0YXJ0ZWQ9ITEsdC5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtPWwsdC5fc3RyYXRlZ3lIV009aSx0Ll93cml0ZUFsZ29yaXRobT1vLHQuX2Nsb3NlQWxnb3JpdGhtPW4sdC5fYWJvcnRBbGdvcml0aG09YTtjb25zdCBzPWJ0KHQpO250KGUscyk7Y29uc3QgdT1yKCk7YihjKHUpLCgoKT0+KHQuX3N0YXJ0ZWQ9ITAsZHQodCksbnVsbCkpLChyPT4odC5fc3RhcnRlZD0hMCxaZShlLHIpLG51bGwpKSl9KGUsbixhLGksbCxzLHIsbyl9KHRoaXMsbywkZShyLDEpLGEpfWdldCBsb2NrZWQoKXtpZighR2UodGhpcykpdGhyb3cgX3QoXCJsb2NrZWRcIik7cmV0dXJuIFhlKHRoaXMpfWFib3J0KGUpe3JldHVybiBHZSh0aGlzKT9YZSh0aGlzKT9kKG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgYWJvcnQgYSBzdHJlYW0gdGhhdCBhbHJlYWR5IGhhcyBhIHdyaXRlclwiKSk6SmUodGhpcyxlKTpkKF90KFwiYWJvcnRcIikpfWNsb3NlKCl7cmV0dXJuIEdlKHRoaXMpP1hlKHRoaXMpP2QobmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjbG9zZSBhIHN0cmVhbSB0aGF0IGFscmVhZHkgaGFzIGEgd3JpdGVyXCIpKTpydCh0aGlzKT9kKG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2xvc2UgYW4gYWxyZWFkeS1jbG9zaW5nIHN0cmVhbVwiKSk6S2UodGhpcyk6ZChfdChcImNsb3NlXCIpKX1nZXRXcml0ZXIoKXtpZighR2UodGhpcykpdGhyb3cgX3QoXCJnZXRXcml0ZXJcIik7cmV0dXJuIG5ldyBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcyl9fWZ1bmN0aW9uIEdlKGUpe3JldHVybiEhcihlKSYmKCEhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJfd3JpdGFibGVTdHJlYW1Db250cm9sbGVyXCIpJiZlIGluc3RhbmNlb2YgV3JpdGFibGVTdHJlYW0pfWZ1bmN0aW9uIFhlKGUpe3JldHVybiB2b2lkIDAhPT1lLl93cml0ZXJ9ZnVuY3Rpb24gSmUoZSx0KXt2YXIgcjtpZihcImNsb3NlZFwiPT09ZS5fc3RhdGV8fFwiZXJyb3JlZFwiPT09ZS5fc3RhdGUpcmV0dXJuIGModm9pZCAwKTtlLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIuX2Fib3J0UmVhc29uPXQsbnVsbD09PShyPWUuX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlci5fYWJvcnRDb250cm9sbGVyKXx8dm9pZCAwPT09cnx8ci5hYm9ydCh0KTtjb25zdCBvPWUuX3N0YXRlO2lmKFwiY2xvc2VkXCI9PT1vfHxcImVycm9yZWRcIj09PW8pcmV0dXJuIGModm9pZCAwKTtpZih2b2lkIDAhPT1lLl9wZW5kaW5nQWJvcnRSZXF1ZXN0KXJldHVybiBlLl9wZW5kaW5nQWJvcnRSZXF1ZXN0Ll9wcm9taXNlO2xldCBuPSExO1wiZXJyb3JpbmdcIj09PW8mJihuPSEwLHQ9dm9pZCAwKTtjb25zdCBhPXUoKChyLG8pPT57ZS5fcGVuZGluZ0Fib3J0UmVxdWVzdD17X3Byb21pc2U6dm9pZCAwLF9yZXNvbHZlOnIsX3JlamVjdDpvLF9yZWFzb246dCxfd2FzQWxyZWFkeUVycm9yaW5nOm59fSkpO3JldHVybiBlLl9wZW5kaW5nQWJvcnRSZXF1ZXN0Ll9wcm9taXNlPWEsbnx8ZXQoZSx0KSxhfWZ1bmN0aW9uIEtlKGUpe2NvbnN0IHQ9ZS5fc3RhdGU7aWYoXCJjbG9zZWRcIj09PXR8fFwiZXJyb3JlZFwiPT09dClyZXR1cm4gZChuZXcgVHlwZUVycm9yKGBUaGUgc3RyZWFtIChpbiAke3R9IHN0YXRlKSBpcyBub3QgaW4gdGhlIHdyaXRhYmxlIHN0YXRlIGFuZCBjYW5ub3QgYmUgY2xvc2VkYCkpO2NvbnN0IHI9dSgoKHQscik9Pntjb25zdCBvPXtfcmVzb2x2ZTp0LF9yZWplY3Q6cn07ZS5fY2xvc2VSZXF1ZXN0PW99KSksbz1lLl93cml0ZXI7dmFyIG47cmV0dXJuIHZvaWQgMCE9PW8mJmUuX2JhY2twcmVzc3VyZSYmXCJ3cml0YWJsZVwiPT09dCYmRXQobyksdWUobj1lLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIsbHQsMCksZHQobikscn1mdW5jdGlvbiBaZShlLHQpe1wid3JpdGFibGVcIiE9PWUuX3N0YXRlP3R0KGUpOmV0KGUsdCl9ZnVuY3Rpb24gZXQoZSx0KXtjb25zdCByPWUuX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcjtlLl9zdGF0ZT1cImVycm9yaW5nXCIsZS5fc3RvcmVkRXJyb3I9dDtjb25zdCBvPWUuX3dyaXRlcjt2b2lkIDAhPT1vJiZpdChvLHQpLCFmdW5jdGlvbihlKXtpZih2b2lkIDA9PT1lLl9pbkZsaWdodFdyaXRlUmVxdWVzdCYmdm9pZCAwPT09ZS5faW5GbGlnaHRDbG9zZVJlcXVlc3QpcmV0dXJuITE7cmV0dXJuITB9KGUpJiZyLl9zdGFydGVkJiZ0dChlKX1mdW5jdGlvbiB0dChlKXtlLl9zdGF0ZT1cImVycm9yZWRcIixlLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXJbUl0oKTtjb25zdCB0PWUuX3N0b3JlZEVycm9yO2lmKGUuX3dyaXRlUmVxdWVzdHMuZm9yRWFjaCgoZT0+e2UuX3JlamVjdCh0KX0pKSxlLl93cml0ZVJlcXVlc3RzPW5ldyBTLHZvaWQgMD09PWUuX3BlbmRpbmdBYm9ydFJlcXVlc3QpcmV0dXJuIHZvaWQgb3QoZSk7Y29uc3Qgcj1lLl9wZW5kaW5nQWJvcnRSZXF1ZXN0O2lmKGUuX3BlbmRpbmdBYm9ydFJlcXVlc3Q9dm9pZCAwLHIuX3dhc0FscmVhZHlFcnJvcmluZylyZXR1cm4gci5fcmVqZWN0KHQpLHZvaWQgb3QoZSk7YihlLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXJbdl0oci5fcmVhc29uKSwoKCk9PihyLl9yZXNvbHZlKCksb3QoZSksbnVsbCkpLCh0PT4oci5fcmVqZWN0KHQpLG90KGUpLG51bGwpKSl9ZnVuY3Rpb24gcnQoZSl7cmV0dXJuIHZvaWQgMCE9PWUuX2Nsb3NlUmVxdWVzdHx8dm9pZCAwIT09ZS5faW5GbGlnaHRDbG9zZVJlcXVlc3R9ZnVuY3Rpb24gb3QoZSl7dm9pZCAwIT09ZS5fY2xvc2VSZXF1ZXN0JiYoZS5fY2xvc2VSZXF1ZXN0Ll9yZWplY3QoZS5fc3RvcmVkRXJyb3IpLGUuX2Nsb3NlUmVxdWVzdD12b2lkIDApO2NvbnN0IHQ9ZS5fd3JpdGVyO3ZvaWQgMCE9PXQmJlN0KHQsZS5fc3RvcmVkRXJyb3IpfWZ1bmN0aW9uIG50KGUsdCl7Y29uc3Qgcj1lLl93cml0ZXI7dm9pZCAwIT09ciYmdCE9PWUuX2JhY2twcmVzc3VyZSYmKHQ/ZnVuY3Rpb24oZSl7UnQoZSl9KHIpOkV0KHIpKSxlLl9iYWNrcHJlc3N1cmU9dH1PYmplY3QuZGVmaW5lUHJvcGVydGllcyhXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUse2Fib3J0OntlbnVtZXJhYmxlOiEwfSxjbG9zZTp7ZW51bWVyYWJsZTohMH0sZ2V0V3JpdGVyOntlbnVtZXJhYmxlOiEwfSxsb2NrZWQ6e2VudW1lcmFibGU6ITB9fSksbihXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUuYWJvcnQsXCJhYm9ydFwiKSxuKFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZS5jbG9zZSxcImNsb3NlXCIpLG4oV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLmdldFdyaXRlcixcImdldFdyaXRlclwiKSxcInN5bWJvbFwiPT10eXBlb2YgZS50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZSxlLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIldyaXRhYmxlU3RyZWFtXCIsY29uZmlndXJhYmxlOiEwfSk7Y2xhc3MgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVye2NvbnN0cnVjdG9yKGUpe2lmKCQoZSwxLFwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyXCIpLGZ1bmN0aW9uKGUsdCl7aWYoIUdlKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7dH0gaXMgbm90IGEgV3JpdGFibGVTdHJlYW0uYCl9KGUsXCJGaXJzdCBwYXJhbWV0ZXJcIiksWGUoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoaXMgc3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gbG9ja2VkIGZvciBleGNsdXNpdmUgd3JpdGluZyBieSBhbm90aGVyIHdyaXRlclwiKTt0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtPWUsZS5fd3JpdGVyPXRoaXM7Y29uc3QgdD1lLl9zdGF0ZTtpZihcIndyaXRhYmxlXCI9PT10KSFydChlKSYmZS5fYmFja3ByZXNzdXJlP1J0KHRoaXMpOnF0KHRoaXMpLGd0KHRoaXMpO2Vsc2UgaWYoXCJlcnJvcmluZ1wiPT09dClUdCh0aGlzLGUuX3N0b3JlZEVycm9yKSxndCh0aGlzKTtlbHNlIGlmKFwiY2xvc2VkXCI9PT10KXF0KHRoaXMpLGd0KHI9dGhpcyksdnQocik7ZWxzZXtjb25zdCB0PWUuX3N0b3JlZEVycm9yO1R0KHRoaXMsdCksd3QodGhpcyx0KX12YXIgcn1nZXQgY2xvc2VkKCl7cmV0dXJuIGF0KHRoaXMpP3RoaXMuX2Nsb3NlZFByb21pc2U6ZChtdChcImNsb3NlZFwiKSl9Z2V0IGRlc2lyZWRTaXplKCl7aWYoIWF0KHRoaXMpKXRocm93IG10KFwiZGVzaXJlZFNpemVcIik7aWYodm9pZCAwPT09dGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbSl0aHJvdyB5dChcImRlc2lyZWRTaXplXCIpO3JldHVybiBmdW5jdGlvbihlKXtjb25zdCB0PWUuX293bmVyV3JpdGFibGVTdHJlYW0scj10Ll9zdGF0ZTtpZihcImVycm9yZWRcIj09PXJ8fFwiZXJyb3JpbmdcIj09PXIpcmV0dXJuIG51bGw7aWYoXCJjbG9zZWRcIj09PXIpcmV0dXJuIDA7cmV0dXJuIGN0KHQuX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcil9KHRoaXMpfWdldCByZWFkeSgpe3JldHVybiBhdCh0aGlzKT90aGlzLl9yZWFkeVByb21pc2U6ZChtdChcInJlYWR5XCIpKX1hYm9ydChlKXtyZXR1cm4gYXQodGhpcyk/dm9pZCAwPT09dGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbT9kKHl0KFwiYWJvcnRcIikpOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIEplKGUuX293bmVyV3JpdGFibGVTdHJlYW0sdCl9KHRoaXMsZSk6ZChtdChcImFib3J0XCIpKX1jbG9zZSgpe2lmKCFhdCh0aGlzKSlyZXR1cm4gZChtdChcImNsb3NlXCIpKTtjb25zdCBlPXRoaXMuX293bmVyV3JpdGFibGVTdHJlYW07cmV0dXJuIHZvaWQgMD09PWU/ZCh5dChcImNsb3NlXCIpKTpydChlKT9kKG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2xvc2UgYW4gYWxyZWFkeS1jbG9zaW5nIHN0cmVhbVwiKSk6S2UodGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbSl9cmVsZWFzZUxvY2soKXtpZighYXQodGhpcykpdGhyb3cgbXQoXCJyZWxlYXNlTG9ja1wiKTt2b2lkIDAhPT10aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtJiZmdW5jdGlvbihlKXtjb25zdCB0PWUuX293bmVyV3JpdGFibGVTdHJlYW0scj1uZXcgVHlwZUVycm9yKFwiV3JpdGVyIHdhcyByZWxlYXNlZCBhbmQgY2FuIG5vIGxvbmdlciBiZSB1c2VkIHRvIG1vbml0b3IgdGhlIHN0cmVhbSdzIGNsb3NlZG5lc3NcIik7aXQoZSxyKSxmdW5jdGlvbihlLHQpe1wicGVuZGluZ1wiPT09ZS5fY2xvc2VkUHJvbWlzZVN0YXRlP1N0KGUsdCk6ZnVuY3Rpb24oZSx0KXt3dChlLHQpfShlLHQpfShlLHIpLHQuX3dyaXRlcj12b2lkIDAsZS5fb3duZXJXcml0YWJsZVN0cmVhbT12b2lkIDB9KHRoaXMpfXdyaXRlKGUpe3JldHVybiBhdCh0aGlzKT92b2lkIDA9PT10aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtP2QoeXQoXCJ3cml0ZSB0b1wiKSk6ZnVuY3Rpb24oZSx0KXtjb25zdCByPWUuX293bmVyV3JpdGFibGVTdHJlYW0sbz1yLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIsbj1mdW5jdGlvbihlLHQpe3RyeXtyZXR1cm4gZS5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtKHQpfWNhdGNoKHQpe3JldHVybiBmdChlLHQpLDF9fShvLHQpO2lmKHIhPT1lLl9vd25lcldyaXRhYmxlU3RyZWFtKXJldHVybiBkKHl0KFwid3JpdGUgdG9cIikpO2NvbnN0IGE9ci5fc3RhdGU7aWYoXCJlcnJvcmVkXCI9PT1hKXJldHVybiBkKHIuX3N0b3JlZEVycm9yKTtpZihydChyKXx8XCJjbG9zZWRcIj09PWEpcmV0dXJuIGQobmV3IFR5cGVFcnJvcihcIlRoZSBzdHJlYW0gaXMgY2xvc2luZyBvciBjbG9zZWQgYW5kIGNhbm5vdCBiZSB3cml0dGVuIHRvXCIpKTtpZihcImVycm9yaW5nXCI9PT1hKXJldHVybiBkKHIuX3N0b3JlZEVycm9yKTtjb25zdCBpPWZ1bmN0aW9uKGUpe3JldHVybiB1KCgodCxyKT0+e2NvbnN0IG89e19yZXNvbHZlOnQsX3JlamVjdDpyfTtlLl93cml0ZVJlcXVlc3RzLnB1c2gobyl9KSl9KHIpO3JldHVybiBmdW5jdGlvbihlLHQscil7dHJ5e3VlKGUsdCxyKX1jYXRjaCh0KXtyZXR1cm4gdm9pZCBmdChlLHQpfWNvbnN0IG89ZS5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO2lmKCFydChvKSYmXCJ3cml0YWJsZVwiPT09by5fc3RhdGUpe250KG8sYnQoZSkpfWR0KGUpfShvLHQsbiksaX0odGhpcyxlKTpkKG10KFwid3JpdGVcIikpfX1mdW5jdGlvbiBhdChlKXtyZXR1cm4hIXIoZSkmJighIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLFwiX293bmVyV3JpdGFibGVTdHJlYW1cIikmJmUgaW5zdGFuY2VvZiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIpfWZ1bmN0aW9uIGl0KGUsdCl7XCJwZW5kaW5nXCI9PT1lLl9yZWFkeVByb21pc2VTdGF0ZT9DdChlLHQpOmZ1bmN0aW9uKGUsdCl7VHQoZSx0KX0oZSx0KX1PYmplY3QuZGVmaW5lUHJvcGVydGllcyhXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLHthYm9ydDp7ZW51bWVyYWJsZTohMH0sY2xvc2U6e2VudW1lcmFibGU6ITB9LHJlbGVhc2VMb2NrOntlbnVtZXJhYmxlOiEwfSx3cml0ZTp7ZW51bWVyYWJsZTohMH0sY2xvc2VkOntlbnVtZXJhYmxlOiEwfSxkZXNpcmVkU2l6ZTp7ZW51bWVyYWJsZTohMH0scmVhZHk6e2VudW1lcmFibGU6ITB9fSksbihXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLmFib3J0LFwiYWJvcnRcIiksbihXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLmNsb3NlLFwiY2xvc2VcIiksbihXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLnJlbGVhc2VMb2NrLFwicmVsZWFzZUxvY2tcIiksbihXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLndyaXRlLFwid3JpdGVcIiksXCJzeW1ib2xcIj09dHlwZW9mIGUudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLGUudG9TdHJpbmdUYWcse3ZhbHVlOlwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyXCIsY29uZmlndXJhYmxlOiEwfSk7Y29uc3QgbHQ9e307Y2xhc3MgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcntjb25zdHJ1Y3Rvcigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGNvbnN0cnVjdG9yXCIpfWdldCBhYm9ydFJlYXNvbigpe2lmKCFzdCh0aGlzKSl0aHJvdyBwdChcImFib3J0UmVhc29uXCIpO3JldHVybiB0aGlzLl9hYm9ydFJlYXNvbn1nZXQgc2lnbmFsKCl7aWYoIXN0KHRoaXMpKXRocm93IHB0KFwic2lnbmFsXCIpO2lmKHZvaWQgMD09PXRoaXMuX2Fib3J0Q29udHJvbGxlcil0aHJvdyBuZXcgVHlwZUVycm9yKFwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuc2lnbmFsIGlzIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJuIHRoaXMuX2Fib3J0Q29udHJvbGxlci5zaWduYWx9ZXJyb3IoZSl7aWYoIXN0KHRoaXMpKXRocm93IHB0KFwiZXJyb3JcIik7XCJ3cml0YWJsZVwiPT09dGhpcy5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtLl9zdGF0ZSYmaHQodGhpcyxlKX1bdl0oZSl7Y29uc3QgdD10aGlzLl9hYm9ydEFsZ29yaXRobShlKTtyZXR1cm4gdXQodGhpcyksdH1bUl0oKXtjZSh0aGlzKX19ZnVuY3Rpb24gc3QoZSl7cmV0dXJuISFyKGUpJiYoISFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxcIl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW1cIikmJmUgaW5zdGFuY2VvZiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKX1mdW5jdGlvbiB1dChlKXtlLl93cml0ZUFsZ29yaXRobT12b2lkIDAsZS5fY2xvc2VBbGdvcml0aG09dm9pZCAwLGUuX2Fib3J0QWxnb3JpdGhtPXZvaWQgMCxlLl9zdHJhdGVneVNpemVBbGdvcml0aG09dm9pZCAwfWZ1bmN0aW9uIGN0KGUpe3JldHVybiBlLl9zdHJhdGVneUhXTS1lLl9xdWV1ZVRvdGFsU2l6ZX1mdW5jdGlvbiBkdChlKXtjb25zdCB0PWUuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtpZighZS5fc3RhcnRlZClyZXR1cm47aWYodm9pZCAwIT09dC5faW5GbGlnaHRXcml0ZVJlcXVlc3QpcmV0dXJuO2lmKFwiZXJyb3JpbmdcIj09PXQuX3N0YXRlKXJldHVybiB2b2lkIHR0KHQpO2lmKDA9PT1lLl9xdWV1ZS5sZW5ndGgpcmV0dXJuO2NvbnN0IHI9ZS5fcXVldWUucGVlaygpLnZhbHVlO3I9PT1sdD9mdW5jdGlvbihlKXtjb25zdCB0PWUuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTsoZnVuY3Rpb24oZSl7ZS5faW5GbGlnaHRDbG9zZVJlcXVlc3Q9ZS5fY2xvc2VSZXF1ZXN0LGUuX2Nsb3NlUmVxdWVzdD12b2lkIDB9KSh0KSxzZShlKTtjb25zdCByPWUuX2Nsb3NlQWxnb3JpdGhtKCk7dXQoZSksYihyLCgoKT0+KGZ1bmN0aW9uKGUpe2UuX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0Ll9yZXNvbHZlKHZvaWQgMCksZS5faW5GbGlnaHRDbG9zZVJlcXVlc3Q9dm9pZCAwLFwiZXJyb3JpbmdcIj09PWUuX3N0YXRlJiYoZS5fc3RvcmVkRXJyb3I9dm9pZCAwLHZvaWQgMCE9PWUuX3BlbmRpbmdBYm9ydFJlcXVlc3QmJihlLl9wZW5kaW5nQWJvcnRSZXF1ZXN0Ll9yZXNvbHZlKCksZS5fcGVuZGluZ0Fib3J0UmVxdWVzdD12b2lkIDApKSxlLl9zdGF0ZT1cImNsb3NlZFwiO2NvbnN0IHQ9ZS5fd3JpdGVyO3ZvaWQgMCE9PXQmJnZ0KHQpfSh0KSxudWxsKSksKGU9PihmdW5jdGlvbihlLHQpe2UuX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0Ll9yZWplY3QodCksZS5faW5GbGlnaHRDbG9zZVJlcXVlc3Q9dm9pZCAwLHZvaWQgMCE9PWUuX3BlbmRpbmdBYm9ydFJlcXVlc3QmJihlLl9wZW5kaW5nQWJvcnRSZXF1ZXN0Ll9yZWplY3QodCksZS5fcGVuZGluZ0Fib3J0UmVxdWVzdD12b2lkIDApLFplKGUsdCl9KHQsZSksbnVsbCkpKX0oZSk6ZnVuY3Rpb24oZSx0KXtjb25zdCByPWUuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTshZnVuY3Rpb24oZSl7ZS5faW5GbGlnaHRXcml0ZVJlcXVlc3Q9ZS5fd3JpdGVSZXF1ZXN0cy5zaGlmdCgpfShyKTtiKGUuX3dyaXRlQWxnb3JpdGhtKHQpLCgoKT0+eyFmdW5jdGlvbihlKXtlLl9pbkZsaWdodFdyaXRlUmVxdWVzdC5fcmVzb2x2ZSh2b2lkIDApLGUuX2luRmxpZ2h0V3JpdGVSZXF1ZXN0PXZvaWQgMH0ocik7Y29uc3QgdD1yLl9zdGF0ZTtpZihzZShlKSwhcnQocikmJlwid3JpdGFibGVcIj09PXQpe2NvbnN0IHQ9YnQoZSk7bnQocix0KX1yZXR1cm4gZHQoZSksbnVsbH0pLCh0PT4oXCJ3cml0YWJsZVwiPT09ci5fc3RhdGUmJnV0KGUpLGZ1bmN0aW9uKGUsdCl7ZS5faW5GbGlnaHRXcml0ZVJlcXVlc3QuX3JlamVjdCh0KSxlLl9pbkZsaWdodFdyaXRlUmVxdWVzdD12b2lkIDAsWmUoZSx0KX0ocix0KSxudWxsKSkpfShlLHIpfWZ1bmN0aW9uIGZ0KGUsdCl7XCJ3cml0YWJsZVwiPT09ZS5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtLl9zdGF0ZSYmaHQoZSx0KX1mdW5jdGlvbiBidChlKXtyZXR1cm4gY3QoZSk8PTB9ZnVuY3Rpb24gaHQoZSx0KXtjb25zdCByPWUuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTt1dChlKSxldChyLHQpfWZ1bmN0aW9uIF90KGUpe3JldHVybiBuZXcgVHlwZUVycm9yKGBXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUuJHtlfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgV3JpdGFibGVTdHJlYW1gKX1mdW5jdGlvbiBwdChlKXtyZXR1cm4gbmV3IFR5cGVFcnJvcihgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuJHtlfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcmApfWZ1bmN0aW9uIG10KGUpe3JldHVybiBuZXcgVHlwZUVycm9yKGBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLiR7ZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcmApfWZ1bmN0aW9uIHl0KGUpe3JldHVybiBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IFwiK2UrXCIgYSBzdHJlYW0gdXNpbmcgYSByZWxlYXNlZCB3cml0ZXJcIil9ZnVuY3Rpb24gZ3QoZSl7ZS5fY2xvc2VkUHJvbWlzZT11KCgodCxyKT0+e2UuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZT10LGUuX2Nsb3NlZFByb21pc2VfcmVqZWN0PXIsZS5fY2xvc2VkUHJvbWlzZVN0YXRlPVwicGVuZGluZ1wifSkpfWZ1bmN0aW9uIHd0KGUsdCl7Z3QoZSksU3QoZSx0KX1mdW5jdGlvbiBTdChlLHQpe3ZvaWQgMCE9PWUuX2Nsb3NlZFByb21pc2VfcmVqZWN0JiYobShlLl9jbG9zZWRQcm9taXNlKSxlLl9jbG9zZWRQcm9taXNlX3JlamVjdCh0KSxlLl9jbG9zZWRQcm9taXNlX3Jlc29sdmU9dm9pZCAwLGUuX2Nsb3NlZFByb21pc2VfcmVqZWN0PXZvaWQgMCxlLl9jbG9zZWRQcm9taXNlU3RhdGU9XCJyZWplY3RlZFwiKX1mdW5jdGlvbiB2dChlKXt2b2lkIDAhPT1lLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUmJihlLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUodm9pZCAwKSxlLl9jbG9zZWRQcm9taXNlX3Jlc29sdmU9dm9pZCAwLGUuX2Nsb3NlZFByb21pc2VfcmVqZWN0PXZvaWQgMCxlLl9jbG9zZWRQcm9taXNlU3RhdGU9XCJyZXNvbHZlZFwiKX1mdW5jdGlvbiBSdChlKXtlLl9yZWFkeVByb21pc2U9dSgoKHQscik9PntlLl9yZWFkeVByb21pc2VfcmVzb2x2ZT10LGUuX3JlYWR5UHJvbWlzZV9yZWplY3Q9cn0pKSxlLl9yZWFkeVByb21pc2VTdGF0ZT1cInBlbmRpbmdcIn1mdW5jdGlvbiBUdChlLHQpe1J0KGUpLEN0KGUsdCl9ZnVuY3Rpb24gcXQoZSl7UnQoZSksRXQoZSl9ZnVuY3Rpb24gQ3QoZSx0KXt2b2lkIDAhPT1lLl9yZWFkeVByb21pc2VfcmVqZWN0JiYobShlLl9yZWFkeVByb21pc2UpLGUuX3JlYWR5UHJvbWlzZV9yZWplY3QodCksZS5fcmVhZHlQcm9taXNlX3Jlc29sdmU9dm9pZCAwLGUuX3JlYWR5UHJvbWlzZV9yZWplY3Q9dm9pZCAwLGUuX3JlYWR5UHJvbWlzZVN0YXRlPVwicmVqZWN0ZWRcIil9ZnVuY3Rpb24gRXQoZSl7dm9pZCAwIT09ZS5fcmVhZHlQcm9taXNlX3Jlc29sdmUmJihlLl9yZWFkeVByb21pc2VfcmVzb2x2ZSh2b2lkIDApLGUuX3JlYWR5UHJvbWlzZV9yZXNvbHZlPXZvaWQgMCxlLl9yZWFkeVByb21pc2VfcmVqZWN0PXZvaWQgMCxlLl9yZWFkeVByb21pc2VTdGF0ZT1cImZ1bGZpbGxlZFwiKX1PYmplY3QuZGVmaW5lUHJvcGVydGllcyhXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSx7YWJvcnRSZWFzb246e2VudW1lcmFibGU6ITB9LHNpZ25hbDp7ZW51bWVyYWJsZTohMH0sZXJyb3I6e2VudW1lcmFibGU6ITB9fSksXCJzeW1ib2xcIj09dHlwZW9mIGUudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSxlLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJcIixjb25maWd1cmFibGU6ITB9KTtjb25zdCBQdD1cInVuZGVmaW5lZFwiIT10eXBlb2YgRE9NRXhjZXB0aW9uP0RPTUV4Y2VwdGlvbjp2b2lkIDA7Y29uc3QgV3Q9ZnVuY3Rpb24oZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSYmXCJvYmplY3RcIiE9dHlwZW9mIGUpcmV0dXJuITE7dHJ5e3JldHVybiBuZXcgZSwhMH1jYXRjaChlKXtyZXR1cm4hMX19KFB0KT9QdDpmdW5jdGlvbigpe2NvbnN0IGU9ZnVuY3Rpb24oZSx0KXt0aGlzLm1lc3NhZ2U9ZXx8XCJcIix0aGlzLm5hbWU9dHx8XCJFcnJvclwiLEVycm9yLmNhcHR1cmVTdGFja1RyYWNlJiZFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLHRoaXMuY29uc3RydWN0b3IpfTtyZXR1cm4gZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSxcImNvbnN0cnVjdG9yXCIse3ZhbHVlOmUsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksZX0oKTtmdW5jdGlvbiBrdChlLHQscixvLG4sYSl7Y29uc3QgaT1lLmdldFJlYWRlcigpLGw9dC5nZXRXcml0ZXIoKTtWdChlKSYmKGUuX2Rpc3R1cmJlZD0hMCk7bGV0IHMsXyxnLHc9ITEsUz0hMSx2PVwicmVhZGFibGVcIixSPVwid3JpdGFibGVcIixUPSExLHE9ITE7Y29uc3QgQz11KChlPT57Zz1lfSkpO2xldCBFPVByb21pc2UucmVzb2x2ZSh2b2lkIDApO3JldHVybiB1KCgoUCxXKT0+e2xldCBrO2Z1bmN0aW9uIE8oKXtpZih3KXJldHVybjtjb25zdCBlPXUoKChlLHQpPT57IWZ1bmN0aW9uIHIobyl7bz9lKCk6ZihmdW5jdGlvbigpe2lmKHcpcmV0dXJuIGMoITApO3JldHVybiBmKGwucmVhZHksKCgpPT5mKGkucmVhZCgpLChlPT4hIWUuZG9uZXx8KEU9bC53cml0ZShlLnZhbHVlKSxtKEUpLCExKSkpKSl9KCkscix0KX0oITEpfSkpO20oZSl9ZnVuY3Rpb24gQigpe3JldHVybiB2PVwiY2xvc2VkXCIscj9MKCk6eigoKCk9PihHZSh0KSYmKFQ9cnQodCksUj10Ll9zdGF0ZSksVHx8XCJjbG9zZWRcIj09PVI/Yyh2b2lkIDApOlwiZXJyb3JpbmdcIj09PVJ8fFwiZXJyb3JlZFwiPT09Uj9kKF8pOihUPSEwLGwuY2xvc2UoKSkpKSwhMSx2b2lkIDApLG51bGx9ZnVuY3Rpb24gQShlKXtyZXR1cm4gd3x8KHY9XCJlcnJvcmVkXCIscz1lLG8/TCghMCxlKTp6KCgoKT0+bC5hYm9ydChlKSksITAsZSkpLG51bGx9ZnVuY3Rpb24gaihlKXtyZXR1cm4gU3x8KFI9XCJlcnJvcmVkXCIsXz1lLG4/TCghMCxlKTp6KCgoKT0+aS5jYW5jZWwoZSkpLCEwLGUpKSxudWxsfWlmKHZvaWQgMCE9PWEmJihrPSgpPT57Y29uc3QgZT12b2lkIDAhPT1hLnJlYXNvbj9hLnJlYXNvbjpuZXcgV3QoXCJBYm9ydGVkXCIsXCJBYm9ydEVycm9yXCIpLHQ9W107b3x8dC5wdXNoKCgoKT0+XCJ3cml0YWJsZVwiPT09Uj9sLmFib3J0KGUpOmModm9pZCAwKSkpLG58fHQucHVzaCgoKCk9PlwicmVhZGFibGVcIj09PXY/aS5jYW5jZWwoZSk6Yyh2b2lkIDApKSkseigoKCk9PlByb21pc2UuYWxsKHQubWFwKChlPT5lKCkpKSkpLCEwLGUpfSxhLmFib3J0ZWQ/aygpOmEuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsaykpLFZ0KGUpJiYodj1lLl9zdGF0ZSxzPWUuX3N0b3JlZEVycm9yKSxHZSh0KSYmKFI9dC5fc3RhdGUsXz10Ll9zdG9yZWRFcnJvcixUPXJ0KHQpKSxWdChlKSYmR2UodCkmJihxPSEwLGcoKSksXCJlcnJvcmVkXCI9PT12KUEocyk7ZWxzZSBpZihcImVycm9yaW5nXCI9PT1SfHxcImVycm9yZWRcIj09PVIpaihfKTtlbHNlIGlmKFwiY2xvc2VkXCI9PT12KUIoKTtlbHNlIGlmKFR8fFwiY2xvc2VkXCI9PT1SKXtjb25zdCBlPW5ldyBUeXBlRXJyb3IoXCJ0aGUgZGVzdGluYXRpb24gd3JpdGFibGUgc3RyZWFtIGNsb3NlZCBiZWZvcmUgYWxsIGRhdGEgY291bGQgYmUgcGlwZWQgdG8gaXRcIik7bj9MKCEwLGUpOnooKCgpPT5pLmNhbmNlbChlKSksITAsZSl9ZnVuY3Rpb24geihlLHQscil7ZnVuY3Rpb24gbygpe3JldHVyblwid3JpdGFibGVcIiE9PVJ8fFQ/bigpOmgoZnVuY3Rpb24oKXtsZXQgZTtyZXR1cm4gYyhmdW5jdGlvbiB0KCl7aWYoZSE9PUUpcmV0dXJuIGU9RSxwKEUsdCx0KX0oKSl9KCksbiksbnVsbH1mdW5jdGlvbiBuKCl7cmV0dXJuIGU/YihlKCksKCgpPT5GKHQscikpLChlPT5GKCEwLGUpKSk6Rih0LHIpLG51bGx9d3x8KHc9ITAscT9vKCk6aChDLG8pKX1mdW5jdGlvbiBMKGUsdCl7eih2b2lkIDAsZSx0KX1mdW5jdGlvbiBGKGUsdCl7cmV0dXJuIFM9ITAsbC5yZWxlYXNlTG9jaygpLGkucmVsZWFzZUxvY2soKSx2b2lkIDAhPT1hJiZhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLGspLGU/Vyh0KTpQKHZvaWQgMCksbnVsbH13fHwoYihpLmNsb3NlZCxCLEEpLGIobC5jbG9zZWQsKGZ1bmN0aW9uKCl7cmV0dXJuIFN8fChSPVwiY2xvc2VkXCIpLG51bGx9KSxqKSkscT9PKCk6eSgoKCk9PntxPSEwLGcoKSxPKCl9KSl9KSl9ZnVuY3Rpb24gT3QoZSx0KXtyZXR1cm4gZnVuY3Rpb24oZSl7dHJ5e3JldHVybiBlLmdldFJlYWRlcih7bW9kZTpcImJ5b2JcIn0pLnJlbGVhc2VMb2NrKCksITB9Y2F0Y2goZSl7cmV0dXJuITF9fShlKT9mdW5jdGlvbihlKXtsZXQgdCxyLG8sbixhLGk9ZS5nZXRSZWFkZXIoKSxsPSExLHM9ITEsZD0hMSxmPSExLGg9ITEscD0hMTtjb25zdCBtPXUoKGU9PnthPWV9KSk7ZnVuY3Rpb24geShlKXtfKGUuY2xvc2VkLCh0PT4oZSE9PWl8fChvLmVycm9yKHQpLG4uZXJyb3IodCksaCYmcHx8YSh2b2lkIDApKSxudWxsKSkpfWZ1bmN0aW9uIGcoKXtsJiYoaS5yZWxlYXNlTG9jaygpLGk9ZS5nZXRSZWFkZXIoKSx5KGkpLGw9ITEpLGIoaS5yZWFkKCksKGU9Pnt2YXIgdCxyO2lmKGQ9ITEsZj0hMSxlLmRvbmUpcmV0dXJuIGh8fG8uY2xvc2UoKSxwfHxuLmNsb3NlKCksbnVsbD09PSh0PW8uYnlvYlJlcXVlc3QpfHx2b2lkIDA9PT10fHx0LnJlc3BvbmQoMCksbnVsbD09PShyPW4uYnlvYlJlcXVlc3QpfHx2b2lkIDA9PT1yfHxyLnJlc3BvbmQoMCksaCYmcHx8YSh2b2lkIDApLG51bGw7Y29uc3QgbD1lLnZhbHVlLHU9bDtsZXQgYz1sO2lmKCFoJiYhcCl0cnl7Yz1sZShsKX1jYXRjaChlKXtyZXR1cm4gby5lcnJvcihlKSxuLmVycm9yKGUpLGEoaS5jYW5jZWwoZSkpLG51bGx9cmV0dXJuIGh8fG8uZW5xdWV1ZSh1KSxwfHxuLmVucXVldWUoYykscz0hMSxkP1MoKTpmJiZ2KCksbnVsbH0pLCgoKT0+KHM9ITEsbnVsbCkpKX1mdW5jdGlvbiB3KHQscil7bHx8KGkucmVsZWFzZUxvY2soKSxpPWUuZ2V0UmVhZGVyKHttb2RlOlwiYnlvYlwifSkseShpKSxsPSEwKTtjb25zdCB1PXI/bjpvLGM9cj9vOm47YihpLnJlYWQodCksKGU9Pnt2YXIgdDtkPSExLGY9ITE7Y29uc3Qgbz1yP3A6aCxuPXI/aDpwO2lmKGUuZG9uZSl7b3x8dS5jbG9zZSgpLG58fGMuY2xvc2UoKTtjb25zdCByPWUudmFsdWU7cmV0dXJuIHZvaWQgMCE9PXImJihvfHx1LmJ5b2JSZXF1ZXN0LnJlc3BvbmRXaXRoTmV3VmlldyhyKSxufHxudWxsPT09KHQ9Yy5ieW9iUmVxdWVzdCl8fHZvaWQgMD09PXR8fHQucmVzcG9uZCgwKSksbyYmbnx8YSh2b2lkIDApLG51bGx9Y29uc3QgbD1lLnZhbHVlO2lmKG4pb3x8dS5ieW9iUmVxdWVzdC5yZXNwb25kV2l0aE5ld1ZpZXcobCk7ZWxzZXtsZXQgZTt0cnl7ZT1sZShsKX1jYXRjaChlKXtyZXR1cm4gdS5lcnJvcihlKSxjLmVycm9yKGUpLGEoaS5jYW5jZWwoZSkpLG51bGx9b3x8dS5ieW9iUmVxdWVzdC5yZXNwb25kV2l0aE5ld1ZpZXcobCksYy5lbnF1ZXVlKGUpfXJldHVybiBzPSExLGQ/UygpOmYmJnYoKSxudWxsfSksKCgpPT4ocz0hMSxudWxsKSkpfWZ1bmN0aW9uIFMoKXtpZihzKXJldHVybiBkPSEwLGModm9pZCAwKTtzPSEwO2NvbnN0IGU9by5ieW9iUmVxdWVzdDtyZXR1cm4gbnVsbD09PWU/ZygpOncoZS52aWV3LCExKSxjKHZvaWQgMCl9ZnVuY3Rpb24gdigpe2lmKHMpcmV0dXJuIGY9ITAsYyh2b2lkIDApO3M9ITA7Y29uc3QgZT1uLmJ5b2JSZXF1ZXN0O3JldHVybiBudWxsPT09ZT9nKCk6dyhlLnZpZXcsITApLGModm9pZCAwKX1mdW5jdGlvbiBSKGUpe2lmKGg9ITAsdD1lLHApe2NvbnN0IGU9W3Qscl0sbz1pLmNhbmNlbChlKTthKG8pfXJldHVybiBtfWZ1bmN0aW9uIFQoZSl7aWYocD0hMCxyPWUsaCl7Y29uc3QgZT1bdCxyXSxvPWkuY2FuY2VsKGUpO2Eobyl9cmV0dXJuIG19Y29uc3QgcT1uZXcgUmVhZGFibGVTdHJlYW0oe3R5cGU6XCJieXRlc1wiLHN0YXJ0KGUpe289ZX0scHVsbDpTLGNhbmNlbDpSfSksQz1uZXcgUmVhZGFibGVTdHJlYW0oe3R5cGU6XCJieXRlc1wiLHN0YXJ0KGUpe249ZX0scHVsbDp2LGNhbmNlbDpUfSk7cmV0dXJuIHkoaSksW3EsQ119KGUpOmZ1bmN0aW9uKGUsdCl7Y29uc3Qgcj1lLmdldFJlYWRlcigpO2xldCBvLG4sYSxpLGwscz0hMSxkPSExLGY9ITEsaD0hMTtjb25zdCBwPXUoKGU9PntsPWV9KSk7ZnVuY3Rpb24gbSgpe3JldHVybiBzPyhkPSEwLGModm9pZCAwKSk6KHM9ITAsYihyLnJlYWQoKSwoZT0+e2lmKGQ9ITEsZS5kb25lKXJldHVybiBmfHxhLmNsb3NlKCksaHx8aS5jbG9zZSgpLGYmJmh8fGwodm9pZCAwKSxudWxsO2NvbnN0IHQ9ZS52YWx1ZSxyPXQsbz10O3JldHVybiBmfHxhLmVucXVldWUociksaHx8aS5lbnF1ZXVlKG8pLHM9ITEsZCYmbSgpLG51bGx9KSwoKCk9PihzPSExLG51bGwpKSksYyh2b2lkIDApKX1mdW5jdGlvbiB5KGUpe2lmKGY9ITAsbz1lLGgpe2NvbnN0IGU9W28sbl0sdD1yLmNhbmNlbChlKTtsKHQpfXJldHVybiBwfWZ1bmN0aW9uIGcoZSl7aWYoaD0hMCxuPWUsZil7Y29uc3QgZT1bbyxuXSx0PXIuY2FuY2VsKGUpO2wodCl9cmV0dXJuIHB9Y29uc3Qgdz1uZXcgUmVhZGFibGVTdHJlYW0oe3N0YXJ0KGUpe2E9ZX0scHVsbDptLGNhbmNlbDp5fSksUz1uZXcgUmVhZGFibGVTdHJlYW0oe3N0YXJ0KGUpe2k9ZX0scHVsbDptLGNhbmNlbDpnfSk7cmV0dXJuIF8oci5jbG9zZWQsKGU9PihhLmVycm9yKGUpLGkuZXJyb3IoZSksZiYmaHx8bCh2b2lkIDApLG51bGwpKSksW3csU119KGUpfWNsYXNzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJ7Y29uc3RydWN0b3IoKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBjb25zdHJ1Y3RvclwiKX1nZXQgZGVzaXJlZFNpemUoKXtpZighQnQodGhpcykpdGhyb3cgRHQoXCJkZXNpcmVkU2l6ZVwiKTtyZXR1cm4gTHQodGhpcyl9Y2xvc2UoKXtpZighQnQodGhpcykpdGhyb3cgRHQoXCJjbG9zZVwiKTtpZighRnQodGhpcykpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBzdHJlYW0gaXMgbm90IGluIGEgc3RhdGUgdGhhdCBwZXJtaXRzIGNsb3NlXCIpOyFmdW5jdGlvbihlKXtpZighRnQoZSkpcmV0dXJuO2NvbnN0IHQ9ZS5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO2UuX2Nsb3NlUmVxdWVzdGVkPSEwLDA9PT1lLl9xdWV1ZS5sZW5ndGgmJihqdChlKSxYdCh0KSl9KHRoaXMpfWVucXVldWUoZSl7aWYoIUJ0KHRoaXMpKXRocm93IER0KFwiZW5xdWV1ZVwiKTtpZighRnQodGhpcykpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBzdHJlYW0gaXMgbm90IGluIGEgc3RhdGUgdGhhdCBwZXJtaXRzIGVucXVldWVcIik7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7aWYoIUZ0KGUpKXJldHVybjtjb25zdCByPWUuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtpZihVdChyKSYmWChyKT4wKUcocix0LCExKTtlbHNle2xldCByO3RyeXtyPWUuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSh0KX1jYXRjaCh0KXt0aHJvdyB6dChlLHQpLHR9dHJ5e3VlKGUsdCxyKX1jYXRjaCh0KXt0aHJvdyB6dChlLHQpLHR9fUF0KGUpfSh0aGlzLGUpfWVycm9yKGUpe2lmKCFCdCh0aGlzKSl0aHJvdyBEdChcImVycm9yXCIpO3p0KHRoaXMsZSl9W1RdKGUpe2NlKHRoaXMpO2NvbnN0IHQ9dGhpcy5fY2FuY2VsQWxnb3JpdGhtKGUpO3JldHVybiBqdCh0aGlzKSx0fVtxXShlKXtjb25zdCB0PXRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtpZih0aGlzLl9xdWV1ZS5sZW5ndGg+MCl7Y29uc3Qgcj1zZSh0aGlzKTt0aGlzLl9jbG9zZVJlcXVlc3RlZCYmMD09PXRoaXMuX3F1ZXVlLmxlbmd0aD8oanQodGhpcyksWHQodCkpOkF0KHRoaXMpLGUuX2NodW5rU3RlcHMocil9ZWxzZSBVKHQsZSksQXQodGhpcyl9W0NdKCl7fX1mdW5jdGlvbiBCdChlKXtyZXR1cm4hIXIoZSkmJighIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLFwiX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbVwiKSYmZSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIpfWZ1bmN0aW9uIEF0KGUpe2NvbnN0IHQ9ZnVuY3Rpb24oZSl7Y29uc3QgdD1lLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07aWYoIUZ0KGUpKXJldHVybiExO2lmKCFlLl9zdGFydGVkKXJldHVybiExO2lmKFV0KHQpJiZYKHQpPjApcmV0dXJuITA7aWYoTHQoZSk+MClyZXR1cm4hMDtyZXR1cm4hMX0oZSk7aWYoIXQpcmV0dXJuO2lmKGUuX3B1bGxpbmcpcmV0dXJuIHZvaWQoZS5fcHVsbEFnYWluPSEwKTtlLl9wdWxsaW5nPSEwO2IoZS5fcHVsbEFsZ29yaXRobSgpLCgoKT0+KGUuX3B1bGxpbmc9ITEsZS5fcHVsbEFnYWluJiYoZS5fcHVsbEFnYWluPSExLEF0KGUpKSxudWxsKSksKHQ9Pih6dChlLHQpLG51bGwpKSl9ZnVuY3Rpb24ganQoZSl7ZS5fcHVsbEFsZ29yaXRobT12b2lkIDAsZS5fY2FuY2VsQWxnb3JpdGhtPXZvaWQgMCxlLl9zdHJhdGVneVNpemVBbGdvcml0aG09dm9pZCAwfWZ1bmN0aW9uIHp0KGUsdCl7Y29uc3Qgcj1lLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07XCJyZWFkYWJsZVwiPT09ci5fc3RhdGUmJihjZShlKSxqdChlKSxKdChyLHQpKX1mdW5jdGlvbiBMdChlKXtjb25zdCB0PWUuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbS5fc3RhdGU7cmV0dXJuXCJlcnJvcmVkXCI9PT10P251bGw6XCJjbG9zZWRcIj09PXQ/MDplLl9zdHJhdGVneUhXTS1lLl9xdWV1ZVRvdGFsU2l6ZX1mdW5jdGlvbiBGdChlKXtyZXR1cm4hZS5fY2xvc2VSZXF1ZXN0ZWQmJlwicmVhZGFibGVcIj09PWUuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbS5fc3RhdGV9ZnVuY3Rpb24gSXQoZSx0LHIsbyl7Y29uc3Qgbj1PYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtsZXQgYSxpLGw7YT12b2lkIDAhPT10LnN0YXJ0PygpPT50LnN0YXJ0KG4pOigpPT57fSxpPXZvaWQgMCE9PXQucHVsbD8oKT0+dC5wdWxsKG4pOigpPT5jKHZvaWQgMCksbD12b2lkIDAhPT10LmNhbmNlbD9lPT50LmNhbmNlbChlKTooKT0+Yyh2b2lkIDApLGZ1bmN0aW9uKGUsdCxyLG8sbixhLGkpe3QuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbT1lLHQuX3F1ZXVlPXZvaWQgMCx0Ll9xdWV1ZVRvdGFsU2l6ZT12b2lkIDAsY2UodCksdC5fc3RhcnRlZD0hMSx0Ll9jbG9zZVJlcXVlc3RlZD0hMSx0Ll9wdWxsQWdhaW49ITEsdC5fcHVsbGluZz0hMSx0Ll9zdHJhdGVneVNpemVBbGdvcml0aG09aSx0Ll9zdHJhdGVneUhXTT1hLHQuX3B1bGxBbGdvcml0aG09byx0Ll9jYW5jZWxBbGdvcml0aG09bixlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXI9dCxiKGMocigpKSwoKCk9Pih0Ll9zdGFydGVkPSEwLEF0KHQpLG51bGwpKSwoZT0+KHp0KHQsZSksbnVsbCkpKX0oZSxuLGEsaSxsLHIsbyl9ZnVuY3Rpb24gRHQoZSl7cmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLiR7ZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJgKX1mdW5jdGlvbiAkdChlLHQscil7cmV0dXJuIEkoZSxyKSxyPT53KGUsdCxbcl0pfWZ1bmN0aW9uIE10KGUsdCxyKXtyZXR1cm4gSShlLHIpLHI9PncoZSx0LFtyXSl9ZnVuY3Rpb24gWXQoZSx0LHIpe3JldHVybiBJKGUscikscj0+ZyhlLHQsW3JdKX1mdW5jdGlvbiBRdChlLHQpe2lmKFwiYnl0ZXNcIiE9PShlPWAke2V9YCkpdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt0fSAnJHtlfScgaXMgbm90IGEgdmFsaWQgZW51bWVyYXRpb24gdmFsdWUgZm9yIFJlYWRhYmxlU3RyZWFtVHlwZWApO3JldHVybiBlfWZ1bmN0aW9uIE50KGUsdCl7aWYoXCJieW9iXCIhPT0oZT1gJHtlfWApKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7dH0gJyR7ZX0nIGlzIG5vdCBhIHZhbGlkIGVudW1lcmF0aW9uIHZhbHVlIGZvciBSZWFkYWJsZVN0cmVhbVJlYWRlck1vZGVgKTtyZXR1cm4gZX1mdW5jdGlvbiBIdChlLHQpe0YoZSx0KTtjb25zdCByPW51bGw9PWU/dm9pZCAwOmUucHJldmVudEFib3J0LG89bnVsbD09ZT92b2lkIDA6ZS5wcmV2ZW50Q2FuY2VsLG49bnVsbD09ZT92b2lkIDA6ZS5wcmV2ZW50Q2xvc2UsYT1udWxsPT1lP3ZvaWQgMDplLnNpZ25hbDtyZXR1cm4gdm9pZCAwIT09YSYmZnVuY3Rpb24oZSx0KXtpZighZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGV8fG51bGw9PT1lKXJldHVybiExO3RyeXtyZXR1cm5cImJvb2xlYW5cIj09dHlwZW9mIGUuYWJvcnRlZH1jYXRjaChlKXtyZXR1cm4hMX19KGUpKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7dH0gaXMgbm90IGFuIEFib3J0U2lnbmFsLmApfShhLGAke3R9IGhhcyBtZW1iZXIgJ3NpZ25hbCcgdGhhdGApLHtwcmV2ZW50QWJvcnQ6Qm9vbGVhbihyKSxwcmV2ZW50Q2FuY2VsOkJvb2xlYW4obykscHJldmVudENsb3NlOkJvb2xlYW4obiksc2lnbmFsOmF9fWZ1bmN0aW9uIHh0KGUsdCl7RihlLHQpO2NvbnN0IHI9bnVsbD09ZT92b2lkIDA6ZS5yZWFkYWJsZTtNKHIsXCJyZWFkYWJsZVwiLFwiUmVhZGFibGVXcml0YWJsZVBhaXJcIiksZnVuY3Rpb24oZSx0KXtpZighSChlKSl0aHJvdyBuZXcgVHlwZUVycm9yKGAke3R9IGlzIG5vdCBhIFJlYWRhYmxlU3RyZWFtLmApfShyLGAke3R9IGhhcyBtZW1iZXIgJ3JlYWRhYmxlJyB0aGF0YCk7Y29uc3Qgbz1udWxsPT1lP3ZvaWQgMDplLndyaXRhYmxlO3JldHVybiBNKG8sXCJ3cml0YWJsZVwiLFwiUmVhZGFibGVXcml0YWJsZVBhaXJcIiksZnVuY3Rpb24oZSx0KXtpZigheChlKSl0aHJvdyBuZXcgVHlwZUVycm9yKGAke3R9IGlzIG5vdCBhIFdyaXRhYmxlU3RyZWFtLmApfShvLGAke3R9IGhhcyBtZW1iZXIgJ3dyaXRhYmxlJyB0aGF0YCkse3JlYWRhYmxlOnIsd3JpdGFibGU6b319T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUse2Nsb3NlOntlbnVtZXJhYmxlOiEwfSxlbnF1ZXVlOntlbnVtZXJhYmxlOiEwfSxlcnJvcjp7ZW51bWVyYWJsZTohMH0sZGVzaXJlZFNpemU6e2VudW1lcmFibGU6ITB9fSksbihSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS5jbG9zZSxcImNsb3NlXCIpLG4oUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuZW5xdWV1ZSxcImVucXVldWVcIiksbihSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS5lcnJvcixcImVycm9yXCIpLFwic3ltYm9sXCI9PXR5cGVvZiBlLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsZS50b1N0cmluZ1RhZyx7dmFsdWU6XCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyXCIsY29uZmlndXJhYmxlOiEwfSk7Y2xhc3MgUmVhZGFibGVTdHJlYW17Y29uc3RydWN0b3IoZT17fSx0PXt9KXt2b2lkIDA9PT1lP2U9bnVsbDpEKGUsXCJGaXJzdCBwYXJhbWV0ZXJcIik7Y29uc3Qgcj1ZZSh0LFwiU2Vjb25kIHBhcmFtZXRlclwiKSxvPWZ1bmN0aW9uKGUsdCl7RihlLHQpO2NvbnN0IHI9ZSxvPW51bGw9PXI/dm9pZCAwOnIuYXV0b0FsbG9jYXRlQ2h1bmtTaXplLG49bnVsbD09cj92b2lkIDA6ci5jYW5jZWwsYT1udWxsPT1yP3ZvaWQgMDpyLnB1bGwsaT1udWxsPT1yP3ZvaWQgMDpyLnN0YXJ0LGw9bnVsbD09cj92b2lkIDA6ci50eXBlO3JldHVybnthdXRvQWxsb2NhdGVDaHVua1NpemU6dm9pZCAwPT09bz92b2lkIDA6TihvLGAke3R9IGhhcyBtZW1iZXIgJ2F1dG9BbGxvY2F0ZUNodW5rU2l6ZScgdGhhdGApLGNhbmNlbDp2b2lkIDA9PT1uP3ZvaWQgMDokdChuLHIsYCR7dH0gaGFzIG1lbWJlciAnY2FuY2VsJyB0aGF0YCkscHVsbDp2b2lkIDA9PT1hP3ZvaWQgMDpNdChhLHIsYCR7dH0gaGFzIG1lbWJlciAncHVsbCcgdGhhdGApLHN0YXJ0OnZvaWQgMD09PWk/dm9pZCAwOll0KGkscixgJHt0fSBoYXMgbWVtYmVyICdzdGFydCcgdGhhdGApLHR5cGU6dm9pZCAwPT09bD92b2lkIDA6UXQobCxgJHt0fSBoYXMgbWVtYmVyICd0eXBlJyB0aGF0YCl9fShlLFwiRmlyc3QgcGFyYW1ldGVyXCIpO3ZhciBuO2lmKChuPXRoaXMpLl9zdGF0ZT1cInJlYWRhYmxlXCIsbi5fcmVhZGVyPXZvaWQgMCxuLl9zdG9yZWRFcnJvcj12b2lkIDAsbi5fZGlzdHVyYmVkPSExLFwiYnl0ZXNcIj09PW8udHlwZSl7aWYodm9pZCAwIT09ci5zaXplKXRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHN0cmF0ZWd5IGZvciBhIGJ5dGUgc3RyZWFtIGNhbm5vdCBoYXZlIGEgc2l6ZSBmdW5jdGlvblwiKTtPZSh0aGlzLG8sJGUociwwKSl9ZWxzZXtjb25zdCBlPU1lKHIpO0l0KHRoaXMsbywkZShyLDEpLGUpfX1nZXQgbG9ja2VkKCl7aWYoIVZ0KHRoaXMpKXRocm93IEt0KFwibG9ja2VkXCIpO3JldHVybiBVdCh0aGlzKX1jYW5jZWwoZSl7cmV0dXJuIFZ0KHRoaXMpP1V0KHRoaXMpP2QobmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYW5jZWwgYSBzdHJlYW0gdGhhdCBhbHJlYWR5IGhhcyBhIHJlYWRlclwiKSk6R3QodGhpcyxlKTpkKEt0KFwiY2FuY2VsXCIpKX1nZXRSZWFkZXIoZSl7aWYoIVZ0KHRoaXMpKXRocm93IEt0KFwiZ2V0UmVhZGVyXCIpO3JldHVybiB2b2lkIDA9PT1mdW5jdGlvbihlLHQpe0YoZSx0KTtjb25zdCByPW51bGw9PWU/dm9pZCAwOmUubW9kZTtyZXR1cm57bW9kZTp2b2lkIDA9PT1yP3ZvaWQgMDpOdChyLGAke3R9IGhhcyBtZW1iZXIgJ21vZGUnIHRoYXRgKX19KGUsXCJGaXJzdCBwYXJhbWV0ZXJcIikubW9kZT9uZXcgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKGUpfSh0aGlzKX1waXBlVGhyb3VnaChlLHQ9e30pe2lmKCFIKHRoaXMpKXRocm93IEt0KFwicGlwZVRocm91Z2hcIik7JChlLDEsXCJwaXBlVGhyb3VnaFwiKTtjb25zdCByPXh0KGUsXCJGaXJzdCBwYXJhbWV0ZXJcIiksbz1IdCh0LFwiU2Vjb25kIHBhcmFtZXRlclwiKTtpZih0aGlzLmxvY2tlZCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUaHJvdWdoIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFJlYWRhYmxlU3RyZWFtXCIpO2lmKHIud3JpdGFibGUubG9ja2VkKXRocm93IG5ldyBUeXBlRXJyb3IoXCJSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRocm91Z2ggY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgV3JpdGFibGVTdHJlYW1cIik7cmV0dXJuIG0oa3QodGhpcyxyLndyaXRhYmxlLG8ucHJldmVudENsb3NlLG8ucHJldmVudEFib3J0LG8ucHJldmVudENhbmNlbCxvLnNpZ25hbCkpLHIucmVhZGFibGV9cGlwZVRvKGUsdD17fSl7aWYoIUgodGhpcykpcmV0dXJuIGQoS3QoXCJwaXBlVG9cIikpO2lmKHZvaWQgMD09PWUpcmV0dXJuIGQoXCJQYXJhbWV0ZXIgMSBpcyByZXF1aXJlZCBpbiAncGlwZVRvJy5cIik7aWYoIXgoZSkpcmV0dXJuIGQobmV3IFR5cGVFcnJvcihcIlJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVG8ncyBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgV3JpdGFibGVTdHJlYW1cIikpO2xldCByO3RyeXtyPUh0KHQsXCJTZWNvbmQgcGFyYW1ldGVyXCIpfWNhdGNoKGUpe3JldHVybiBkKGUpfXJldHVybiB0aGlzLmxvY2tlZD9kKG5ldyBUeXBlRXJyb3IoXCJSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFJlYWRhYmxlU3RyZWFtXCIpKTplLmxvY2tlZD9kKG5ldyBUeXBlRXJyb3IoXCJSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFdyaXRhYmxlU3RyZWFtXCIpKTprdCh0aGlzLGUsci5wcmV2ZW50Q2xvc2Usci5wcmV2ZW50QWJvcnQsci5wcmV2ZW50Q2FuY2VsLHIuc2lnbmFsKX10ZWUoKXtpZighSCh0aGlzKSl0aHJvdyBLdChcInRlZVwiKTtpZih0aGlzLmxvY2tlZCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHRlZSBhIHN0cmVhbSB0aGF0IGFscmVhZHkgaGFzIGEgcmVhZGVyXCIpO3JldHVybiBPdCh0aGlzKX12YWx1ZXMoZSl7aWYoIUgodGhpcykpdGhyb3cgS3QoXCJ2YWx1ZXNcIik7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7Y29uc3Qgcj1lLmdldFJlYWRlcigpLG89bmV3IHRlKHIsdCksbj1PYmplY3QuY3JlYXRlKHJlKTtyZXR1cm4gbi5fYXN5bmNJdGVyYXRvckltcGw9byxufSh0aGlzLGZ1bmN0aW9uKGUsdCl7RihlLHQpO2NvbnN0IHI9bnVsbD09ZT92b2lkIDA6ZS5wcmV2ZW50Q2FuY2VsO3JldHVybntwcmV2ZW50Q2FuY2VsOkJvb2xlYW4ocil9fShlLFwiRmlyc3QgcGFyYW1ldGVyXCIpLnByZXZlbnRDYW5jZWwpfX1mdW5jdGlvbiBWdChlKXtyZXR1cm4hIXIoZSkmJighIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLFwiX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlclwiKSYmZSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtKX1mdW5jdGlvbiBVdChlKXtyZXR1cm4gdm9pZCAwIT09ZS5fcmVhZGVyfWZ1bmN0aW9uIEd0KGUscil7aWYoZS5fZGlzdHVyYmVkPSEwLFwiY2xvc2VkXCI9PT1lLl9zdGF0ZSlyZXR1cm4gYyh2b2lkIDApO2lmKFwiZXJyb3JlZFwiPT09ZS5fc3RhdGUpcmV0dXJuIGQoZS5fc3RvcmVkRXJyb3IpO1h0KGUpO2NvbnN0IG89ZS5fcmVhZGVyO2lmKHZvaWQgMCE9PW8mJkZlKG8pKXtjb25zdCBlPW8uX3JlYWRJbnRvUmVxdWVzdHM7by5fcmVhZEludG9SZXF1ZXN0cz1uZXcgUyxlLmZvckVhY2goKGU9PntlLl9jbG9zZVN0ZXBzKHZvaWQgMCl9KSl9cmV0dXJuIHAoZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyW1RdKHIpLHQpfWZ1bmN0aW9uIFh0KGUpe2UuX3N0YXRlPVwiY2xvc2VkXCI7Y29uc3QgdD1lLl9yZWFkZXI7aWYodm9pZCAwIT09dCYmKGoodCksSyh0KSkpe2NvbnN0IGU9dC5fcmVhZFJlcXVlc3RzO3QuX3JlYWRSZXF1ZXN0cz1uZXcgUyxlLmZvckVhY2goKGU9PntlLl9jbG9zZVN0ZXBzKCl9KSl9fWZ1bmN0aW9uIEp0KGUsdCl7ZS5fc3RhdGU9XCJlcnJvcmVkXCIsZS5fc3RvcmVkRXJyb3I9dDtjb25zdCByPWUuX3JlYWRlcjt2b2lkIDAhPT1yJiYoQShyLHQpLEsocik/WihyLHQpOkllKHIsdCkpfWZ1bmN0aW9uIEt0KGUpe3JldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUuJHtlfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1gKX1mdW5jdGlvbiBadChlLHQpe0YoZSx0KTtjb25zdCByPW51bGw9PWU/dm9pZCAwOmUuaGlnaFdhdGVyTWFyaztyZXR1cm4gTShyLFwiaGlnaFdhdGVyTWFya1wiLFwiUXVldWluZ1N0cmF0ZWd5SW5pdFwiKSx7aGlnaFdhdGVyTWFyazpZKHIpfX1PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUse2NhbmNlbDp7ZW51bWVyYWJsZTohMH0sZ2V0UmVhZGVyOntlbnVtZXJhYmxlOiEwfSxwaXBlVGhyb3VnaDp7ZW51bWVyYWJsZTohMH0scGlwZVRvOntlbnVtZXJhYmxlOiEwfSx0ZWU6e2VudW1lcmFibGU6ITB9LHZhbHVlczp7ZW51bWVyYWJsZTohMH0sbG9ja2VkOntlbnVtZXJhYmxlOiEwfX0pLG4oUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLmNhbmNlbCxcImNhbmNlbFwiKSxuKFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5nZXRSZWFkZXIsXCJnZXRSZWFkZXJcIiksbihSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRocm91Z2gsXCJwaXBlVGhyb3VnaFwiKSxuKFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVG8sXCJwaXBlVG9cIiksbihSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUudGVlLFwidGVlXCIpLG4oUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnZhbHVlcyxcInZhbHVlc1wiKSxcInN5bWJvbFwiPT10eXBlb2YgZS50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZSxlLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIlJlYWRhYmxlU3RyZWFtXCIsY29uZmlndXJhYmxlOiEwfSksXCJzeW1ib2xcIj09dHlwZW9mIGUuYXN5bmNJdGVyYXRvciYmT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZSxlLmFzeW5jSXRlcmF0b3Ise3ZhbHVlOlJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS52YWx1ZXMsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfSk7Y29uc3QgZXI9ZT0+ZS5ieXRlTGVuZ3RoO24oZXIsXCJzaXplXCIpO2NsYXNzIEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3l7Y29uc3RydWN0b3IoZSl7JChlLDEsXCJCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5XCIpLGU9WnQoZSxcIkZpcnN0IHBhcmFtZXRlclwiKSx0aGlzLl9ieXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyaz1lLmhpZ2hXYXRlck1hcmt9Z2V0IGhpZ2hXYXRlck1hcmsoKXtpZighcnIodGhpcykpdGhyb3cgdHIoXCJoaWdoV2F0ZXJNYXJrXCIpO3JldHVybiB0aGlzLl9ieXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFya31nZXQgc2l6ZSgpe2lmKCFycih0aGlzKSl0aHJvdyB0cihcInNpemVcIik7cmV0dXJuIGVyfX1mdW5jdGlvbiB0cihlKXtyZXR1cm4gbmV3IFR5cGVFcnJvcihgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUuJHtlfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneWApfWZ1bmN0aW9uIHJyKGUpe3JldHVybiEhcihlKSYmKCEhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJfYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmtcIikmJmUgaW5zdGFuY2VvZiBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5KX1PYmplY3QuZGVmaW5lUHJvcGVydGllcyhCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZSx7aGlnaFdhdGVyTWFyazp7ZW51bWVyYWJsZTohMH0sc2l6ZTp7ZW51bWVyYWJsZTohMH19KSxcInN5bWJvbFwiPT10eXBlb2YgZS50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLGUudG9TdHJpbmdUYWcse3ZhbHVlOlwiQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneVwiLGNvbmZpZ3VyYWJsZTohMH0pO2NvbnN0IG9yPSgpPT4xO24ob3IsXCJzaXplXCIpO2NsYXNzIENvdW50UXVldWluZ1N0cmF0ZWd5e2NvbnN0cnVjdG9yKGUpeyQoZSwxLFwiQ291bnRRdWV1aW5nU3RyYXRlZ3lcIiksZT1adChlLFwiRmlyc3QgcGFyYW1ldGVyXCIpLHRoaXMuX2NvdW50UXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyaz1lLmhpZ2hXYXRlck1hcmt9Z2V0IGhpZ2hXYXRlck1hcmsoKXtpZighYXIodGhpcykpdGhyb3cgbnIoXCJoaWdoV2F0ZXJNYXJrXCIpO3JldHVybiB0aGlzLl9jb3VudFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmt9Z2V0IHNpemUoKXtpZighYXIodGhpcykpdGhyb3cgbnIoXCJzaXplXCIpO3JldHVybiBvcn19ZnVuY3Rpb24gbnIoZSl7cmV0dXJuIG5ldyBUeXBlRXJyb3IoYENvdW50UXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZS4ke2V9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBDb3VudFF1ZXVpbmdTdHJhdGVneWApfWZ1bmN0aW9uIGFyKGUpe3JldHVybiEhcihlKSYmKCEhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJfY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrXCIpJiZlIGluc3RhbmNlb2YgQ291bnRRdWV1aW5nU3RyYXRlZ3kpfWZ1bmN0aW9uIGlyKGUsdCxyKXtyZXR1cm4gSShlLHIpLHI9PncoZSx0LFtyXSl9ZnVuY3Rpb24gbHIoZSx0LHIpe3JldHVybiBJKGUscikscj0+ZyhlLHQsW3JdKX1mdW5jdGlvbiBzcihlLHQscil7cmV0dXJuIEkoZSxyKSwocixvKT0+dyhlLHQsW3Isb10pfU9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvdW50UXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZSx7aGlnaFdhdGVyTWFyazp7ZW51bWVyYWJsZTohMH0sc2l6ZTp7ZW51bWVyYWJsZTohMH19KSxcInN5bWJvbFwiPT10eXBlb2YgZS50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KENvdW50UXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZSxlLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIkNvdW50UXVldWluZ1N0cmF0ZWd5XCIsY29uZmlndXJhYmxlOiEwfSk7Y2xhc3MgVHJhbnNmb3JtU3RyZWFte2NvbnN0cnVjdG9yKGU9e30sdD17fSxyPXt9KXt2b2lkIDA9PT1lJiYoZT1udWxsKTtjb25zdCBvPVllKHQsXCJTZWNvbmQgcGFyYW1ldGVyXCIpLG49WWUocixcIlRoaXJkIHBhcmFtZXRlclwiKSxhPWZ1bmN0aW9uKGUsdCl7RihlLHQpO2NvbnN0IHI9bnVsbD09ZT92b2lkIDA6ZS5mbHVzaCxvPW51bGw9PWU/dm9pZCAwOmUucmVhZGFibGVUeXBlLG49bnVsbD09ZT92b2lkIDA6ZS5zdGFydCxhPW51bGw9PWU/dm9pZCAwOmUudHJhbnNmb3JtLGk9bnVsbD09ZT92b2lkIDA6ZS53cml0YWJsZVR5cGU7cmV0dXJue2ZsdXNoOnZvaWQgMD09PXI/dm9pZCAwOmlyKHIsZSxgJHt0fSBoYXMgbWVtYmVyICdmbHVzaCcgdGhhdGApLHJlYWRhYmxlVHlwZTpvLHN0YXJ0OnZvaWQgMD09PW4/dm9pZCAwOmxyKG4sZSxgJHt0fSBoYXMgbWVtYmVyICdzdGFydCcgdGhhdGApLHRyYW5zZm9ybTp2b2lkIDA9PT1hP3ZvaWQgMDpzcihhLGUsYCR7dH0gaGFzIG1lbWJlciAndHJhbnNmb3JtJyB0aGF0YCksd3JpdGFibGVUeXBlOml9fShlLFwiRmlyc3QgcGFyYW1ldGVyXCIpO2lmKHZvaWQgMCE9PWEucmVhZGFibGVUeXBlKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCByZWFkYWJsZVR5cGUgc3BlY2lmaWVkXCIpO2lmKHZvaWQgMCE9PWEud3JpdGFibGVUeXBlKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB3cml0YWJsZVR5cGUgc3BlY2lmaWVkXCIpO2NvbnN0IGk9JGUobiwwKSxsPU1lKG4pLHM9JGUobywxKSxmPU1lKG8pO2xldCBiOyFmdW5jdGlvbihlLHQscixvLG4sYSl7ZnVuY3Rpb24gaSgpe3JldHVybiB0fWZ1bmN0aW9uIGwodCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7Y29uc3Qgcj1lLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyO2lmKGUuX2JhY2twcmVzc3VyZSl7cmV0dXJuIHAoZS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSwoKCk9PntpZihcImVycm9yaW5nXCI9PT0oR2UoZS5fd3JpdGFibGUpP2UuX3dyaXRhYmxlLl9zdGF0ZTplLl93cml0YWJsZVN0YXRlKSl0aHJvdyBHZShlLl93cml0YWJsZSk/ZS5fd3JpdGFibGUuX3N0b3JlZEVycm9yOmUuX3dyaXRhYmxlU3RvcmVkRXJyb3I7cmV0dXJuIHByKHIsdCl9KSl9cmV0dXJuIHByKHIsdCl9KGUsdCl9ZnVuY3Rpb24gcyh0KXtyZXR1cm4gZnVuY3Rpb24oZSx0KXtyZXR1cm4gY3IoZSx0KSxjKHZvaWQgMCl9KGUsdCl9ZnVuY3Rpb24gdSgpe3JldHVybiBmdW5jdGlvbihlKXtjb25zdCB0PWUuX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIscj10Ll9mbHVzaEFsZ29yaXRobSgpO3JldHVybiBocih0KSxwKHIsKCgpPT57aWYoXCJlcnJvcmVkXCI9PT1lLl9yZWFkYWJsZVN0YXRlKXRocm93IGUuX3JlYWRhYmxlU3RvcmVkRXJyb3I7Z3IoZSkmJndyKGUpfSksKHQ9Pnt0aHJvdyBjcihlLHQpLGUuX3JlYWRhYmxlU3RvcmVkRXJyb3J9KSl9KGUpfWZ1bmN0aW9uIGQoKXtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIGZyKGUsITEpLGUuX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2V9KGUpfWZ1bmN0aW9uIGYodCl7cmV0dXJuIGRyKGUsdCksYyh2b2lkIDApfWUuX3dyaXRhYmxlU3RhdGU9XCJ3cml0YWJsZVwiLGUuX3dyaXRhYmxlU3RvcmVkRXJyb3I9dm9pZCAwLGUuX3dyaXRhYmxlSGFzSW5GbGlnaHRPcGVyYXRpb249ITEsZS5fd3JpdGFibGVTdGFydGVkPSExLGUuX3dyaXRhYmxlPWZ1bmN0aW9uKGUsdCxyLG8sbixhLGkpe3JldHVybiBuZXcgV3JpdGFibGVTdHJlYW0oe3N0YXJ0KHIpe2UuX3dyaXRhYmxlQ29udHJvbGxlcj1yO3RyeXtjb25zdCB0PXIuc2lnbmFsO3ZvaWQgMCE9PXQmJnQuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsKCgpPT57XCJ3cml0YWJsZVwiPT09ZS5fd3JpdGFibGVTdGF0ZSYmKGUuX3dyaXRhYmxlU3RhdGU9XCJlcnJvcmluZ1wiLHQucmVhc29uJiYoZS5fd3JpdGFibGVTdG9yZWRFcnJvcj10LnJlYXNvbikpfSkpfWNhdGNoKGUpe31yZXR1cm4gcCh0KCksKCgpPT4oZS5fd3JpdGFibGVTdGFydGVkPSEwLENyKGUpLG51bGwpKSwodD0+e3Rocm93IGUuX3dyaXRhYmxlU3RhcnRlZD0hMCxScihlLHQpLHR9KSl9LHdyaXRlOnQ9PihmdW5jdGlvbihlKXtlLl93cml0YWJsZUhhc0luRmxpZ2h0T3BlcmF0aW9uPSEwfShlKSxwKHIodCksKCgpPT4oZnVuY3Rpb24oZSl7ZS5fd3JpdGFibGVIYXNJbkZsaWdodE9wZXJhdGlvbj0hMX0oZSksQ3IoZSksbnVsbCkpLCh0PT57dGhyb3cgZnVuY3Rpb24oZSx0KXtlLl93cml0YWJsZUhhc0luRmxpZ2h0T3BlcmF0aW9uPSExLFJyKGUsdCl9KGUsdCksdH0pKSksY2xvc2U6KCk9PihmdW5jdGlvbihlKXtlLl93cml0YWJsZUhhc0luRmxpZ2h0T3BlcmF0aW9uPSEwfShlKSxwKG8oKSwoKCk9PihmdW5jdGlvbihlKXtlLl93cml0YWJsZUhhc0luRmxpZ2h0T3BlcmF0aW9uPSExO1wiZXJyb3JpbmdcIj09PWUuX3dyaXRhYmxlU3RhdGUmJihlLl93cml0YWJsZVN0b3JlZEVycm9yPXZvaWQgMCk7ZS5fd3JpdGFibGVTdGF0ZT1cImNsb3NlZFwifShlKSxudWxsKSksKHQ9Pnt0aHJvdyBmdW5jdGlvbihlLHQpe2UuX3dyaXRhYmxlSGFzSW5GbGlnaHRPcGVyYXRpb249ITEsZS5fd3JpdGFibGVTdGF0ZSxScihlLHQpfShlLHQpLHR9KSkpLGFib3J0OnQ9PihlLl93cml0YWJsZVN0YXRlPVwiZXJyb3JlZFwiLGUuX3dyaXRhYmxlU3RvcmVkRXJyb3I9dCxuKHQpKX0se2hpZ2hXYXRlck1hcms6YSxzaXplOml9KX0oZSxpLGwsdSxzLHIsbyksZS5fcmVhZGFibGVTdGF0ZT1cInJlYWRhYmxlXCIsZS5fcmVhZGFibGVTdG9yZWRFcnJvcj12b2lkIDAsZS5fcmVhZGFibGVDbG9zZVJlcXVlc3RlZD0hMSxlLl9yZWFkYWJsZVB1bGxpbmc9ITEsZS5fcmVhZGFibGU9ZnVuY3Rpb24oZSx0LHIsbyxuLGEpe3JldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe3N0YXJ0OnI9PihlLl9yZWFkYWJsZUNvbnRyb2xsZXI9cix0KCkuY2F0Y2goKHQ9PntTcihlLHQpfSkpKSxwdWxsOigpPT4oZS5fcmVhZGFibGVQdWxsaW5nPSEwLHIoKS5jYXRjaCgodD0+e1NyKGUsdCl9KSkpLGNhbmNlbDp0PT4oZS5fcmVhZGFibGVTdGF0ZT1cImNsb3NlZFwiLG8odCkpfSx7aGlnaFdhdGVyTWFyazpuLHNpemU6YX0pfShlLGksZCxmLG4sYSksZS5fYmFja3ByZXNzdXJlPXZvaWQgMCxlLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlPXZvaWQgMCxlLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlX3Jlc29sdmU9dm9pZCAwLGZyKGUsITApLGUuX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXI9dm9pZCAwfSh0aGlzLHUoKGU9PntiPWV9KSkscyxmLGksbCksZnVuY3Rpb24oZSx0KXtjb25zdCByPU9iamVjdC5jcmVhdGUoVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtsZXQgbyxuO289dm9pZCAwIT09dC50cmFuc2Zvcm0/ZT0+dC50cmFuc2Zvcm0oZSxyKTplPT57dHJ5e3JldHVybiBfcihyLGUpLGModm9pZCAwKX1jYXRjaChlKXtyZXR1cm4gZChlKX19O249dm9pZCAwIT09dC5mbHVzaD8oKT0+dC5mbHVzaChyKTooKT0+Yyh2b2lkIDApOyFmdW5jdGlvbihlLHQscixvKXt0Ll9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtPWUsZS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcj10LHQuX3RyYW5zZm9ybUFsZ29yaXRobT1yLHQuX2ZsdXNoQWxnb3JpdGhtPW99KGUscixvLG4pfSh0aGlzLGEpLHZvaWQgMCE9PWEuc3RhcnQ/YihhLnN0YXJ0KHRoaXMuX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIpKTpiKHZvaWQgMCl9Z2V0IHJlYWRhYmxlKCl7aWYoIXVyKHRoaXMpKXRocm93IHlyKFwicmVhZGFibGVcIik7cmV0dXJuIHRoaXMuX3JlYWRhYmxlfWdldCB3cml0YWJsZSgpe2lmKCF1cih0aGlzKSl0aHJvdyB5cihcIndyaXRhYmxlXCIpO3JldHVybiB0aGlzLl93cml0YWJsZX19ZnVuY3Rpb24gdXIoZSl7cmV0dXJuISFyKGUpJiYoISFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxcIl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyXCIpJiZlIGluc3RhbmNlb2YgVHJhbnNmb3JtU3RyZWFtKX1mdW5jdGlvbiBjcihlLHQpe1NyKGUsdCksZHIoZSx0KX1mdW5jdGlvbiBkcihlLHQpe2hyKGUuX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIpLGZ1bmN0aW9uKGUsdCl7ZS5fd3JpdGFibGVDb250cm9sbGVyLmVycm9yKHQpO1wid3JpdGFibGVcIj09PWUuX3dyaXRhYmxlU3RhdGUmJlRyKGUsdCl9KGUsdCksZS5fYmFja3ByZXNzdXJlJiZmcihlLCExKX1mdW5jdGlvbiBmcihlLHQpe3ZvaWQgMCE9PWUuX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UmJmUuX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZSgpLGUuX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2U9dSgodD0+e2UuX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZT10fSkpLGUuX2JhY2twcmVzc3VyZT10fU9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUse3JlYWRhYmxlOntlbnVtZXJhYmxlOiEwfSx3cml0YWJsZTp7ZW51bWVyYWJsZTohMH19KSxcInN5bWJvbFwiPT10eXBlb2YgZS50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUsZS50b1N0cmluZ1RhZyx7dmFsdWU6XCJUcmFuc2Zvcm1TdHJlYW1cIixjb25maWd1cmFibGU6ITB9KTtjbGFzcyBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcntjb25zdHJ1Y3Rvcigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGNvbnN0cnVjdG9yXCIpfWdldCBkZXNpcmVkU2l6ZSgpe2lmKCFicih0aGlzKSl0aHJvdyBtcihcImRlc2lyZWRTaXplXCIpO3JldHVybiB2cih0aGlzLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtKX1lbnF1ZXVlKGUpe2lmKCFicih0aGlzKSl0aHJvdyBtcihcImVucXVldWVcIik7X3IodGhpcyxlKX1lcnJvcihlKXtpZighYnIodGhpcykpdGhyb3cgbXIoXCJlcnJvclwiKTt2YXIgdDt0PWUsY3IodGhpcy5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbSx0KX10ZXJtaW5hdGUoKXtpZighYnIodGhpcykpdGhyb3cgbXIoXCJ0ZXJtaW5hdGVcIik7IWZ1bmN0aW9uKGUpe2NvbnN0IHQ9ZS5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbTtncih0KSYmd3IodCk7Y29uc3Qgcj1uZXcgVHlwZUVycm9yKFwiVHJhbnNmb3JtU3RyZWFtIHRlcm1pbmF0ZWRcIik7ZHIodCxyKX0odGhpcyl9fWZ1bmN0aW9uIGJyKGUpe3JldHVybiEhcihlKSYmKCEhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJfY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbVwiKSYmZSBpbnN0YW5jZW9mIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKX1mdW5jdGlvbiBocihlKXtlLl90cmFuc2Zvcm1BbGdvcml0aG09dm9pZCAwLGUuX2ZsdXNoQWxnb3JpdGhtPXZvaWQgMH1mdW5jdGlvbiBfcihlLHQpe2NvbnN0IHI9ZS5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbTtpZighZ3IocikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlJlYWRhYmxlIHNpZGUgaXMgbm90IGluIGEgc3RhdGUgdGhhdCBwZXJtaXRzIGVucXVldWVcIik7dHJ5eyFmdW5jdGlvbihlLHQpe2UuX3JlYWRhYmxlUHVsbGluZz0hMTt0cnl7ZS5fcmVhZGFibGVDb250cm9sbGVyLmVucXVldWUodCl9Y2F0Y2godCl7dGhyb3cgU3IoZSx0KSx0fX0ocix0KX1jYXRjaChlKXt0aHJvdyBkcihyLGUpLHIuX3JlYWRhYmxlU3RvcmVkRXJyb3J9Y29uc3Qgbz1mdW5jdGlvbihlKXtyZXR1cm4hZnVuY3Rpb24oZSl7aWYoIWdyKGUpKXJldHVybiExO2lmKGUuX3JlYWRhYmxlUHVsbGluZylyZXR1cm4hMDtpZih2cihlKT4wKXJldHVybiEwO3JldHVybiExfShlKX0ocik7byE9PXIuX2JhY2twcmVzc3VyZSYmZnIociwhMCl9ZnVuY3Rpb24gcHIoZSx0KXtyZXR1cm4gcChlLl90cmFuc2Zvcm1BbGdvcml0aG0odCksdm9pZCAwLCh0PT57dGhyb3cgY3IoZS5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbSx0KSx0fSkpfWZ1bmN0aW9uIG1yKGUpe3JldHVybiBuZXcgVHlwZUVycm9yKGBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuJHtlfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJgKX1mdW5jdGlvbiB5cihlKXtyZXR1cm4gbmV3IFR5cGVFcnJvcihgVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZS4ke2V9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBUcmFuc2Zvcm1TdHJlYW1gKX1mdW5jdGlvbiBncihlKXtyZXR1cm4hZS5fcmVhZGFibGVDbG9zZVJlcXVlc3RlZCYmXCJyZWFkYWJsZVwiPT09ZS5fcmVhZGFibGVTdGF0ZX1mdW5jdGlvbiB3cihlKXtlLl9yZWFkYWJsZVN0YXRlPVwiY2xvc2VkXCIsZS5fcmVhZGFibGVDbG9zZVJlcXVlc3RlZD0hMCxlLl9yZWFkYWJsZUNvbnRyb2xsZXIuY2xvc2UoKX1mdW5jdGlvbiBTcihlLHQpe1wicmVhZGFibGVcIj09PWUuX3JlYWRhYmxlU3RhdGUmJihlLl9yZWFkYWJsZVN0YXRlPVwiZXJyb3JlZFwiLGUuX3JlYWRhYmxlU3RvcmVkRXJyb3I9dCksZS5fcmVhZGFibGVDb250cm9sbGVyLmVycm9yKHQpfWZ1bmN0aW9uIHZyKGUpe3JldHVybiBlLl9yZWFkYWJsZUNvbnRyb2xsZXIuZGVzaXJlZFNpemV9ZnVuY3Rpb24gUnIoZSx0KXtcIndyaXRhYmxlXCIhPT1lLl93cml0YWJsZVN0YXRlP3FyKGUpOlRyKGUsdCl9ZnVuY3Rpb24gVHIoZSx0KXtlLl93cml0YWJsZVN0YXRlPVwiZXJyb3JpbmdcIixlLl93cml0YWJsZVN0b3JlZEVycm9yPXQsIWZ1bmN0aW9uKGUpe3JldHVybiBlLl93cml0YWJsZUhhc0luRmxpZ2h0T3BlcmF0aW9ufShlKSYmZS5fd3JpdGFibGVTdGFydGVkJiZxcihlKX1mdW5jdGlvbiBxcihlKXtlLl93cml0YWJsZVN0YXRlPVwiZXJyb3JlZFwifWZ1bmN0aW9uIENyKGUpe1wiZXJyb3JpbmdcIj09PWUuX3dyaXRhYmxlU3RhdGUmJnFyKGUpfU9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSx7ZW5xdWV1ZTp7ZW51bWVyYWJsZTohMH0sZXJyb3I6e2VudW1lcmFibGU6ITB9LHRlcm1pbmF0ZTp7ZW51bWVyYWJsZTohMH0sZGVzaXJlZFNpemU6e2VudW1lcmFibGU6ITB9fSksbihUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuZW5xdWV1ZSxcImVucXVldWVcIiksbihUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuZXJyb3IsXCJlcnJvclwiKSxuKFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS50ZXJtaW5hdGUsXCJ0ZXJtaW5hdGVcIiksXCJzeW1ib2xcIj09dHlwZW9mIGUudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsZS50b1N0cmluZ1RhZyx7dmFsdWU6XCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclwiLGNvbmZpZ3VyYWJsZTohMH0pO2V4cG9ydHtCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5LENvdW50UXVldWluZ1N0cmF0ZWd5LFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIsUmVhZGFibGVTdHJlYW0sUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QsUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcixSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIsVHJhbnNmb3JtU3RyZWFtLFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLFdyaXRhYmxlU3RyZWFtLFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIsV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyfTtcbiJdLCJuYW1lcyI6WyJlIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJ0IiwiciIsIm8iLCJuIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsImNvbmZpZ3VyYWJsZSIsImEiLCJQcm9taXNlIiwiaSIsInByb3RvdHlwZSIsInRoZW4iLCJsIiwicmVzb2x2ZSIsImJpbmQiLCJzIiwicmVqZWN0IiwidSIsImMiLCJkIiwiZiIsImNhbGwiLCJiIiwiaCIsIl8iLCJwIiwibSIsInkiLCJxdWV1ZU1pY3JvdGFzayIsImciLCJUeXBlRXJyb3IiLCJGdW5jdGlvbiIsImFwcGx5IiwidyIsIlMiLCJjb25zdHJ1Y3RvciIsIl9jdXJzb3IiLCJfc2l6ZSIsIl9mcm9udCIsIl9lbGVtZW50cyIsIl9uZXh0IiwiX2JhY2siLCJsZW5ndGgiLCJwdXNoIiwic2hpZnQiLCJmb3JFYWNoIiwicGVlayIsInYiLCJSIiwiVCIsInEiLCJDIiwiRSIsIl9vd25lclJlYWRhYmxlU3RyZWFtIiwiX3JlYWRlciIsIl9zdGF0ZSIsIk8iLCJqIiwiQiIsIl9zdG9yZWRFcnJvciIsIlAiLCJHdCIsIlciLCJBIiwiX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciIsImsiLCJfY2xvc2VkUHJvbWlzZSIsIl9jbG9zZWRQcm9taXNlX3Jlc29sdmUiLCJfY2xvc2VkUHJvbWlzZV9yZWplY3QiLCJ6IiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJMIiwiTWF0aCIsInRydW5jIiwiY2VpbCIsImZsb29yIiwiRiIsIkkiLCJEIiwiJCIsIk0iLCJZIiwiUSIsIk4iLCJNQVhfU0FGRV9JTlRFR0VSIiwiSCIsImdldFJlYWRlciIsImxvY2tlZCIsIngiLCJnZXRXcml0ZXIiLCJWIiwiVnQiLCJVIiwiX3JlYWRSZXF1ZXN0cyIsIkciLCJfY2xvc2VTdGVwcyIsIl9jaHVua1N0ZXBzIiwiWCIsIkoiLCJLIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIiwiVXQiLCJjbG9zZWQiLCJlZSIsImNhbmNlbCIsInJlYWQiLCJfZGlzdHVyYmVkIiwiX2Vycm9yU3RlcHMiLCJkb25lIiwicmVsZWFzZUxvY2siLCJaIiwiaGFzT3duUHJvcGVydHkiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZW51bWVyYWJsZSIsInRvU3RyaW5nVGFnIiwidGUiLCJfb25nb2luZ1Byb21pc2UiLCJfaXNGaW5pc2hlZCIsIl9wcmV2ZW50Q2FuY2VsIiwibmV4dCIsIl9uZXh0U3RlcHMiLCJyZXR1cm4iLCJfcmV0dXJuU3RlcHMiLCJyZSIsIm9lIiwiX2FzeW5jSXRlcmF0b3JJbXBsIiwibmUiLCJhc3luY0l0ZXJhdG9yIiwid3JpdGFibGUiLCJhZSIsImlzTmFOIiwiaWUiLCJVaW50OEFycmF5Iiwic2V0IiwibGUiLCJzbGljZSIsIkFycmF5QnVmZmVyIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJzZSIsIl9xdWV1ZSIsIl9xdWV1ZVRvdGFsU2l6ZSIsInNpemUiLCJ1ZSIsIlJhbmdlRXJyb3IiLCJjZSIsIlJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QiLCJ2aWV3IiwiZmUiLCJCZSIsIl92aWV3IiwicmVzcG9uZCIsIl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciIsIl9wZW5kaW5nUHVsbEludG9zIiwiX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0iLCJieXRlc0ZpbGxlZCIsInFlIiwicmVzcG9uZFdpdGhOZXdWaWV3IiwiaXNWaWV3IiwiYnVmZmVyQnl0ZUxlbmd0aCIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIiLCJieW9iUmVxdWVzdCIsImRlIiwiQWUiLCJfYnlvYlJlcXVlc3QiLCJjcmVhdGUiLCJkZXNpcmVkU2l6ZSIsImtlIiwiY2xvc2UiLCJfY2xvc2VSZXF1ZXN0ZWQiLCJQZSIsIkVlIiwiWHQiLCJlbnF1ZXVlIiwiUmUiLCJyZWFkZXJUeXBlIiwiZ2UiLCJXZSIsIm1lIiwiQ2UiLCJMZSIsIlRlIiwiYmUiLCJlcnJvciIsImhlIiwiX2NhbmNlbEFsZ29yaXRobSIsIl9hdXRvQWxsb2NhdGVDaHVua1NpemUiLCJlbGVtZW50U2l6ZSIsInZpZXdDb25zdHJ1Y3RvciIsIl9zdGFydGVkIiwiemUiLCJfcHVsbGluZyIsIl9wdWxsQWdhaW4iLCJfcHVsbEFsZ29yaXRobSIsIl9lIiwicGUiLCJfcmVhZEludG9SZXF1ZXN0cyIsInllIiwid2UiLCJtaW4iLCJTZSIsInZlIiwiSnQiLCJfc3RyYXRlZ3lIV00iLCJPZSIsInN0YXJ0IiwicHVsbCIsImF1dG9BbGxvY2F0ZUNodW5rU2l6ZSIsImplIiwiRmUiLCJSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIiLCJEZSIsIkRhdGFWaWV3IiwiQllURVNfUEVSX0VMRU1FTlQiLCJJZSIsIiRlIiwiaGlnaFdhdGVyTWFyayIsIk1lIiwiWWUiLCJRZSIsIk5lIiwiSGUiLCJ4ZSIsIlZlIiwiVWUiLCJBYm9ydENvbnRyb2xsZXIiLCJXcml0YWJsZVN0cmVhbSIsImFib3J0IiwidHlwZSIsIndyaXRlIiwiX3dyaXRlciIsIl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIiLCJfd3JpdGVSZXF1ZXN0cyIsIl9pbkZsaWdodFdyaXRlUmVxdWVzdCIsIl9jbG9zZVJlcXVlc3QiLCJfaW5GbGlnaHRDbG9zZVJlcXVlc3QiLCJfcGVuZGluZ0Fib3J0UmVxdWVzdCIsIl9iYWNrcHJlc3N1cmUiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwiX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbSIsIl9hYm9ydFJlYXNvbiIsIl9hYm9ydENvbnRyb2xsZXIiLCJfc3RyYXRlZ3lTaXplQWxnb3JpdGhtIiwiX3dyaXRlQWxnb3JpdGhtIiwiX2Nsb3NlQWxnb3JpdGhtIiwiX2Fib3J0QWxnb3JpdGhtIiwiYnQiLCJudCIsImR0IiwiWmUiLCJHZSIsIl90IiwiWGUiLCJKZSIsInJ0IiwiS2UiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIiLCJfcHJvbWlzZSIsIl9yZXNvbHZlIiwiX3JlamVjdCIsIl9yZWFzb24iLCJfd2FzQWxyZWFkeUVycm9yaW5nIiwiZXQiLCJFdCIsImx0IiwidHQiLCJpdCIsIm90IiwiU3QiLCJSdCIsIl9vd25lcldyaXRhYmxlU3RyZWFtIiwicXQiLCJndCIsIlR0IiwidnQiLCJ3dCIsImF0IiwibXQiLCJ5dCIsImN0IiwicmVhZHkiLCJfcmVhZHlQcm9taXNlIiwiX2Nsb3NlZFByb21pc2VTdGF0ZSIsImZ0IiwiX3JlYWR5UHJvbWlzZVN0YXRlIiwiQ3QiLCJhYm9ydFJlYXNvbiIsInN0IiwicHQiLCJzaWduYWwiLCJodCIsInV0IiwiX3JlYWR5UHJvbWlzZV9yZXNvbHZlIiwiX3JlYWR5UHJvbWlzZV9yZWplY3QiLCJQdCIsIkRPTUV4Y2VwdGlvbiIsIld0IiwibWVzc2FnZSIsIm5hbWUiLCJFcnJvciIsImNhcHR1cmVTdGFja1RyYWNlIiwia3QiLCJyZWFzb24iLCJhbGwiLCJtYXAiLCJhYm9ydGVkIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJPdCIsIm1vZGUiLCJSZWFkYWJsZVN0cmVhbSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJCdCIsIkR0IiwiTHQiLCJGdCIsIl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0iLCJqdCIsInp0IiwiQXQiLCJJdCIsIiR0IiwiTXQiLCJZdCIsIlF0IiwiTnQiLCJIdCIsInByZXZlbnRBYm9ydCIsInByZXZlbnRDYW5jZWwiLCJwcmV2ZW50Q2xvc2UiLCJCb29sZWFuIiwieHQiLCJyZWFkYWJsZSIsIkt0IiwicGlwZVRocm91Z2giLCJwaXBlVG8iLCJ0ZWUiLCJ2YWx1ZXMiLCJadCIsImVyIiwiQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSIsIl9ieXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyayIsInJyIiwidHIiLCJvciIsIkNvdW50UXVldWluZ1N0cmF0ZWd5IiwiX2NvdW50UXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyayIsImFyIiwibnIiLCJpciIsImxyIiwic3IiLCJUcmFuc2Zvcm1TdHJlYW0iLCJmbHVzaCIsInJlYWRhYmxlVHlwZSIsInRyYW5zZm9ybSIsIndyaXRhYmxlVHlwZSIsIl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyIiwiX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UiLCJfd3JpdGFibGUiLCJfd3JpdGFibGVTdGF0ZSIsIl93cml0YWJsZVN0b3JlZEVycm9yIiwicHIiLCJjciIsIl9mbHVzaEFsZ29yaXRobSIsImhyIiwiX3JlYWRhYmxlU3RhdGUiLCJfcmVhZGFibGVTdG9yZWRFcnJvciIsImdyIiwid3IiLCJmciIsImRyIiwiX3dyaXRhYmxlSGFzSW5GbGlnaHRPcGVyYXRpb24iLCJfd3JpdGFibGVTdGFydGVkIiwiX3dyaXRhYmxlQ29udHJvbGxlciIsIkNyIiwiUnIiLCJfcmVhZGFibGVDbG9zZVJlcXVlc3RlZCIsIl9yZWFkYWJsZVB1bGxpbmciLCJfcmVhZGFibGUiLCJfcmVhZGFibGVDb250cm9sbGVyIiwiY2F0Y2giLCJTciIsIl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlX3Jlc29sdmUiLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsIl9yIiwiX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0iLCJfdHJhbnNmb3JtQWxnb3JpdGhtIiwidXIiLCJ5ciIsIlRyIiwiYnIiLCJtciIsInZyIiwidGVybWluYXRlIiwicXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/web-streams-polyfill/dist/ponyfill.mjs\n");

/***/ })

};
;